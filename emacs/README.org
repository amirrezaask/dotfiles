#+TITLE: AmirrezaAsk Emacs configuration
#+AUTHOR: amirrezaask
* Introduction
=Emacs= is one of the oldest softwares that has active development and community after 40 years passed from the initial release, but why is
that ? Why when there battries included, easy to use, full-featured solutions like =VSCode=, =Jetbrains IDEA= (I mean whole Jetbrains family),
 =Atom=, =Sublime=, etc... people still use =Emacs=, What is the reason that keeps these programs alive? Is it just some people want to look
cool ? Or is there really something ? We are going to take a journey into the deepest parts of EMACS and find the answer.

* What is Emacs ?
** Editor ? IDE ? Mail client ? Window manager ? Terminal emulator ? Lisp interpreter ? all of them ? none ?
At the 70s at =MIT= AI lab computers were running an editor called =TECO= which was modal editor, as the time passed
problems of =TECO= started to create the need for a new editor paradigm, and one new implemention
 catched on very well, guy named =Fred Wright= created an editor called =E=, which was much more similar to modern
editors we know, and Stallman added same functionality to =TECO= program.
At the year 1984 =Stallman= Sta[INC]
So Emacs is an editor implemented in Emacs-lisp which is an Lisp dialect implemented in C, so basically Emacs is
a Lisp interpreter which happens to have a editor inside as well. All editor functionality is written in pure emacs-lisp
or they have the API for emacs-lisp so you can change them, you can actually change almost anything in Emacs since
every thing is a function or a variable defined in Emacs-lisp and evaluated using Emacs internal lisp evaluator and 
Emacs-lisp like many lisps has no function scoping, in simpler terms there is no private functions or variables so 
you can change the most core parts of EMACS easily with just redefining them.
* Ascend from darkness
** Installing Emacs
Installing Emacs is easy, if you are on a =GNU/Linux= distro you should be able to get it from the package manager and
in =macOS= it's available in =homebrew= and you can download windows version from gnu/emacs website.
** Let your feet get wet
*** Opening a file
Open up Emacs, what you see is a tedious white screen with an ugly Emacs logo and some links for tutorials on Emacs
(these links are actually useful take a look at them). First let's get on the same page, from this point to the
end of the document =C= in keybindings refers to control key and =M= refers to Meta(Alt) key, =S= is shift and =s= 
is super key. Open a file by pressing =<C-x C-f>=, you get a prompt to enter a file name, enter some random file name
an hit enter, file is opened and you can see the content. Let's create a table to remember the keychords we are using

| Keychord | functionality |
| C-x C-f  | opens a file  |

*** Motions
Let's move around, ofcourse you can use the mouse and click around or the arrow keys but there are more efficient
ways doing this, Just press =<C-f>= you see your cursor moves forward by a character, now press =<C-b>= and your 
cursor moves backward by a character so lets update our table. Remember there are so much more in motions these two
were just examples.

| Keychord | functionality                 |
| C-f      | moves forward by a character  |
| C-b      | moves backward by a character |

*** Emacs is self documenting
Do you remember that I told you in Emacs every thing is just an Elisp(Emacs-lisp) function, let's discuss that.
Let me introduce you to the Emacs self documenting feature, press =<C-h k>=, you should be prompted then enter
=<C-x C-f>= a new window(we'll discuss this concept later), you see a document that tolds you what this keychord
is bound to and the documentation of that function, in this case you should see that =<C-x C-f>= is bound to 
=find-file= command and you have the option to see the actual source code of that function. =<C-h>= is the prefix 
for all Emacs help commands and these keys themselves runs elisp functions you can actually do the =<C-h k>=
on itself and see the function behind it so let's update our table and from now on we write the actual function name 
in our table.

| Keychord | function          |
|----------+-------------------|
| C-h k    | describe-key      |
| C-h f    | describe-function |
| C-h v    | describe-variable |

*** Elisp
I'm not going to do a complete tutorial on Elisp just gonna tell you how you can stay alive in Emacs.
**** Hello World
Elisp or Emacs-Lisp is the language that almost all Emacs functions are written in, so let's tip our toes in it as 
well.
Open up a new file ( you already know how to do that ) name that anything but with the extension of =.el=.
at the first line write the following 
#+BEGIN_SRC 
(message "Hello World")
#+END_SRC
and then move your cursor to the end of the line using =<C-e>= and then press =<C-x C-e>=, now look at the =minibuffer=
you see the ="Hello World"= in there. Don't forget to =describe-key= the two keychords that you just used.
**** Loading (Evaluating) file
:PROPERTIES:
  :header-args: :tangle no
  :END:
You can evaluate eLisp expressions like you now know but you also can load a whole elisp file using =load-file= function
#+BEGIN_SRC 
(load-file "file.el")
#+END_SRC
** Start Your configuration
 Emacs configuration is nothing other than a simple elisp file that emacs loads at the startup we can specify that
 using =-l= flag to load specific file. so let's do that. Open an elisp file and name that =config.el=, and just put
 a simple hello world message in it, now go to terminal and enter =emacs -l config.el= when this instance of emacs starts
 up =switch-to-buffer= (this is a function you can describe-function it and find the keybindings little exercise)
 to the buffer called =*Messages*= and you should see your message in that buffer somewhere.
 Now you can write any elisp code in your config.el file and emacs always evaluates them as long as you pass the
 -l flag, but the conventional way of doing emacs configuration is using =~/.emacs.d/init.el= file which emacs 
 automatically loads in the startup, it's kind of the default file for this purpose.
** Introducing Emacs 27
Emacs 27 has a lot to offer, a new json parser that is implemented natively (C code) so it should speed
up the JSON based operations like LSP a lot, another thing about Emacs 27 is =early-init.el= file that gets
loaded before init.el and before GUI and package manager starts so it can help us configure Emacs even further.
* Emacs internals optimizations
:PROPERTIES:
  :header-args: :tangle no
  :END:
I moved all of the code of this part to =early-init.el=.
** GC
Emacs is a really old software, many of the default values in Emacs aren't actually suited for today's
modern computers. Emacs has a built-in Garbage collector that does garbage collection every time Emacs lisp
VM reaches a threshold of memory usage, and this garbage collector sweeps are sometimes annoying, but remember 
garbage collector threshold is a tricky setting, if you set it to low you will start experiencing a lot of GC sweeps that slow you down
and if you set it very high GC sweeps take forever to finish. Default Emacs =gc-cons-threshold= is set to =800000=
which is not really enough specially for Emacs startup since it needs to scan through all your installed packages
so we are going to increase it during startup time and then after Emacs initialization we can decrease it again.
#+begin_src emacs-lisp
  (message "$$$$$$$$$$$$$$$$ should be disabled")
  (setq gc-cons-threshold (* 1024 1024 100)) ;; 100MB for Emacs initialization process
  (add-hook 'after-init-hook (lambda ()
                               (setq gc-cons-threshold (* 1024 1024 20)))) ;; reseting the gc cons to 20MB
#+end_src
** file-name-handler-alist
Emacs has a global variable called =file-name-handler-alist=, it stores handlers for various file extensions, before =use-package= era we used to
add new file extensions to this variable to load their respective handler, On every file open, Emacs looks and scans through this variable to see if it
can find a match for given file, but during the startup process we are going to only evaluate stuff so we don't need file-handlers, as result we are going 
to set this file's value to a nil value during startup and restore it's original value after emacs initialization.
#+begin_src emacs-lisp
  (defvar file-name-handler-alist-bak file-name-handler-alist "file name handler backup.")
  (setq file-name-handler-alist nil)
  (add-hook 'after-init-hook (lambda () (setq file-name-handler-alist file-name-handler-alist-bak)))
#+end_src
* Setup package manager
Now that we know how to move around, open files, and do some elisp magic in emacs it's time to start configuring 
emacs for our own needs. Before we start, we need the final ingredient for our configuration and that's how 
to install 3rd party packages for emacs, basically elisp codes written by other people.
** Package.el setup
:PROPERTIES:
  :header-args: :tangle no
  :END:
Emacs is bundled with package.el, we can use that out of the box, we only need to =require= it, require is similar
to =load-file= with some diferences like it don't need full path when code is in you =load-path= (load-path
is a variable you can describe-variable it) and it loads each file only once so if you require a file multiple 
times it only loads once.
#+BEGIN_SRC emacs-lisp
(require 'package)
#+END_SRC
package.el reads all installed packages even if they are not referenced by your init we need to stop it 
from doing so.
#+BEGIN_SRC emacs-lisp
(setq package-enable-at-startup nil)
#+END_SRC
As I told you elpa is a lot like linux repos, and like them you can add external repos to it as well, =Melpa=
is the biggest and most complete package repo in the planet of Emacs and we are adding it to our repos.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/"))
  (package-initialize)
 #+END_SRC
Like all linux repos we need to refresh the index of the package manager but we don't need Emacs does that 
every time that we start emacs, we need to that only when package-archive-contents is nil so we use =when=
macro of elisp (like always you can describe-function it).
#+BEGIN_SRC emacs-lisp
   (when (null package-archive-contents)
     (package-refresh-contents))
#+END_SRC
*** Use-package
  Now the world is our oyster, you can actually browse the [[https://github.com/emacs-tw/awesome-emacs]] and install
  any package you seem fit using 
  But as the number of installed packages gets bigger emacs starts slow when starting up and managing and organizing
  your init.el file getting harder and harder to the point that they call it =Emacs bankrupty=.
  So to avoid this problems Emacs maintainer =John wiegly= created a tool called =use-package= that helps you oraganize
  your init.el file and even lazy-load packages, It's an awesome tool so let's install it.
  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
      (package-install 'use-package))
    (require 'use-package)
  #+END_SRC
  Feel free to read the [[https://github.com/jwiegley/use-package][use-package docs]], it's amazingly useful.
** Straight.el
=straight.el= is the next generation of Emacs package managers that just use git repos as the way
of installing packages, upsides of using =straight.el= instead of =package.el= are
+ You can install packages that are not available on MELPA (icomplete-vertical forexample)
+ If you are willing to contribute to a package it's as simple as just =git checkout=
+ straight loads just the packages you installed and mention in your init file so packages that are installed 
but no longer used are not included in loading/scanning procedure.
#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  (straight-use-package 'use-package)
#+end_src
* Evil always wins
"Emacs is a great operating system lacking only a decent editor", I always find this quote to be
true Emacs as software package/framework is amazing I mean I think people that are working on various 
types of frameworks out there should really start studying Emacs as an inspiration of how you can write 
a customizable yet robust software that would last for 40 years and yet new generations start using it yet
Emacs editor actually doesn't follow Emacs extensibility and composibility philosophy a lot, Emacs editor is based
on specific targeted functions, you have =delete-word=, it just deletes a word you can not tell it to delete two
words (yes you can do C-2 M-d) but it's not that user-friendly actually, so without further ado let's decend into
darkness. 
=Note=: I still believe that VIM is better editor but since old habits die hard, I'm gonna continue with Emacs
keybindings
#+begin_src emacs-lisp
  (use-package evil 
    :disabled t
    :straight t
    :init
    (setq evil-want-keybinding nil)
    :config
    (evil-mode +1))


  (use-package evil-collection 
    :disabled t
    :straight t 
    :config 
    (evil-collection-init))

  (use-package evil-magit 

    :disabled t
    :straight t)

  (use-package evil-surround 

    :disabled t
    :straight t)

  (use-package evil-commentary 

    :disabled t
    :straight t)

  (use-package general

    :straight t
    :config
    (general-create-definer space-leader-lord :prefix "SPC" :states 'normal :keymaps 'override)
    (general-create-definer space-leader :prefix "SPC" :states 'normal)
    (space-leader-lord
      "b l" 'switch-to-buffer
      "k b" 'kill-buffer
      "SPC" 'execute-extended-command
      "m w" 'delete-other-windows
      "o w" 'other-window
      "d w" 'delete-window
      "s r" 'split-window-right
      "s b" 'split-window-below
      "e s" 'eval-last-sexp
      "f f" 'find-file
      )
  )

#+end_src
* Exwm (Emacs X window manager)
#+begin_src emacs-lisp
  (use-package exwm 
    :disabled t
    :straight t
    :config 
    (require 'exwm-config)
    (require 'exwm-randr)

    (exwm-config-default))
    ;; (setq exwm-randr-workspace-output-plist '(1 "HDMI-2" 0 "eDP-1"))
    ;; (add-hook 'exwm-randr-screen-change-hook
    ;;           (lambda ()
    ;;             (start-process-shell-command
    ;;              "xrandr" nil "xrandr --output HDMI-2 --right-of eDP-1 --auto")))
    ;; (exwm-xrandr-enable))

#+end_src
* UI
** Themes
 Now that we have use-package we can start installing thems, packages, etc. Let's start by installing some thems.
 for some time now I am using modus themes by the amazing =Protesilaos Stavrou= (btw check his youtube channel) which are simple but elegant themes
 but if you want a more modern look like =VSCode= or =Atom= you can use =doom-themes= as well.
 ([[https://github.com/hlissner/emacs-doom-themes/tree/screenshots][Doom Themes Screenshots]])
 #+BEGIN_SRC emacs-lisp
   (use-package modus-operandi-theme :straight t :defer t)
   (use-package modus-vivendi-theme :straight t :defer t)
   (use-package spacemacs-theme :straight t :defer t)
   (use-package doom-themes :straight t :defer t)
 #+END_SRC
 You probably notice the =:defer= part in use-package, with =:defer= keyword (:something is called a keyword in elisp)
 use-package knows that we don't need this package to be loaded in startup, since we actually don't need all of our themes
 to be loaded at startup. Another keyword that you see is =:ensure= that is telling use-package to make certain
 that this package is installed, and if it's not install it from elpa repo.
 Now let's set a theme
 #+BEGIN_SRC emacs-lisp
   (use-package custom
     :demand
     :bind (("<f12>" . amirreza/toggle-color-mode))
     :config
     (defvar amirreza/current-mode 'dark "Current color of Emacs.")
     (defvar amirreza/dark-theme 'spacemacs-dark)
     (defvar amirreza/light-theme 'spacemacs-light)
     (defun amirreza/apply-color (mode)
       "Apply current color mode to Emacs."
       (if (eq amirreza/current-mode 'dark)
           (load-theme amirreza/dark-theme t)
         (load-theme  amirreza/light-theme t)))

     (defun amirreza/toggle-color-mode ()
       "Toggle current mode to the opposite"
       (interactive)
       (if (eq amirreza/current-mode 'dark)
           (setq amirreza/current-mode 'light)
         (setq amirreza/current-mode 'dark))
       (amirreza/apply-color amirreza/current-mode))
     (amirreza/apply-color amirreza/current-mode))


 #+END_SRC
**** Performance Tip 
About 95% of packages we use don't need to be loaded at startup and =:defer= is only one of the multiple
ways of lazy-loading in use-package we will see others later on.
** Font
 To use specific font in Emacs you just need to call a function, that's easy ha ??
 #+BEGIN_SRC emacs-lisp
 (defvar amirreza/font "mononoki-12")
 (set-face-attribute 'default t :font amirreza/font)
 (set-frame-font amirreza/font nil t)
 #+END_SRC
 If you evaluate code above you see the font changes.
 Now let's write some elisp, let's say that we want to have a function that we can call and change 
 our font interactively, let's write it.
 #+BEGIN_SRC emacs-lisp
   (defun hitchhiker/change-font (font size)
     (interactive "sFont: \nnSize: ")
     (set-face-attribute 'default t :font (format "%s-%d" font size))
     (set-frame-font (format "%s-%d" font size) nil t))
 #+END_SRC
 I'm not gonna discuss this function line by line, I'm only going to discuss calling it for now,
 for calling this function we have two ways, calling it from the code, or calling it interactively
 but how ? Emacs has a default keychord called M-x (execute-extended-command) that calls a interactive
 function interactively, many packages has these kind of functions for example load-theme that we used
 before is interactive as well, if we call it we will prompted to enter the font first and then the size
 and volla :).

** Icons
Emacs by default has no icons anywhere, but if you like icons forexample in the file browser
you need to install a package for that. For icons we are going to use =all-the-icons= package which
is a gourges icon package for emacs.
#+BEGIN_SRC emacs-lisp :eval no
  (use-package all-the-icons
    :straight t
    :disabled t
    :commands (all-the-icons-octicon
	       all-the-icons-faicon
	       all-the-icons-fileicon
	       all-the-icons-wicon
	       all-the-icons-material
	       all-the-icons-alltheicon))

  (use-package all-the-icons-dired
    :straight t
    :disabled t
    :init
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC
=:commands= in use-package defers the loading of the package until on of listed commands (interactive functions)
is called, basically first buffer that wants to use that it will get loaded. =:init= means when emacs started 
no matter what are the other options evaluate the forms after =:init=.
** Modeline
let's customize our modeline, =lighters= are representation of modes in Emacs modeline, for example =Org-mode= lighter is =Org=, we can customize lighters using delight package, to edit them or
remove them completely, delight package also adds a use-package keyword =:delight= so we can customize packages more declaratively.  
#+BEGIN_SRC emacs-lisp
(use-package delight
  :straight t
  :after use-package)
#+END_SRC
* Emacs Modes Introduction
First let's talk about modes, Modes are the conventional way to add functionality to Emacs.
There are two groups of modes, Major modes and minor modes, Major modes are single modes that 
get's loaded with a specific file extension, and they provide basic syntax highlighting.
but minor modes are modes that can be loaded together for a buffer, so each buffer has a single 
major mode, and multiple minor modes that added different abilities to emacs for a buffer.
Forexample line numbers is a minor mode that is enabled globally for all buffers so all buffers
show line numbers.
Now that we have cool looks, 
* Editor
*** Defaults
***** Line width
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config
    (setq-default fill-column 80))
#+END_SRC
***** Tab
Set default tab width.
#+BEGIN_SRC emacs-lisp
(use-package emacs
    :config
    (setq-default
    indent-tabs-mode nil
    tab-width 4))
#+END_SRC
***** Encoding
Use UTF-8 everywhere.
#+BEGIN_SRC emacs-lisp
  (use-package mule
  :config 
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (prefer-coding-system 'utf-8))
#+END_SRC
*** Set a new custom file
#+BEGIN_SRC emacs-lisp
  (use-package cus-edit
    :custom
    (custom-file "~/.emacs.d/custom.el"))
#+END_SRC
*** Show keychords more fast
when we start using modifier keys emacs shows them in minibuffer but the initial value
of the is too much so we can decrease it.
#+BEGIN_SRC emacs-lisp
(use-package emacs 
:custom
(echo-keystrokes 0.1))
#+END_SRC

*** don't type yes every time
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Edit configuration
So many times when I am using Emacs I find a problem or a possible feature to add it's nice to have a keybinding that just opens this file.
#+BEGIN_SRC emacs-lisp
    (defun amirreza/edit-configuration ()
        (interactive)
        (find-file (expand-file-name "README.org" user-emacs-directory)))

    (global-set-key (kbd "C-c c e") 'amirreza/edit-configuration)
    (space-leader "e c" 'amirreza/edit-configuration)
#+END_SRC
*** TRAMP
#+begin_src emacs-lisp
  (use-package tramp
    :custom
    (tramp-default-method "ssh"))
#+end_src
*** Large files handling
Since Emacs by default is not that good in handling large files,
but again Emacs community is here to help
#+begin_src emacs-lisp
(use-package vlf :straight t)
#+end_src
*** Beacon
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :straight t
  :config (beacon-mode 1))
#+END_SRC
*** Some general keybindings
#+BEGIN_SRC emacs-lisp
;; sane zoom-in and zoom-out 
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C-_") 'text-scale-decrease)

;; custom motions
(global-set-key (kbd "M-n") (lambda () (interactive) (next-line 5)))
(global-set-key (kbd "M-p") (lambda () (interactive) (previous-line 5)))

#+END_SRC
*** Reduce clutter in emacs frame
 #+BEGIN_SRC emacs-lisp
   (use-package emacs
     :config
     (if (< emacs-major-version 27) ;; from Emacs 27 this settings are moved to `early-init.el'
         (tool-bar-mode 0) ;; disable tool-bar 
       (scroll-bar-mode 0) ;; disable scroll-bar
       (menu-bar-mode 0) ;; disable menu-bar
     )
     (setq use-dialog-box nil) ;; ask quesions in minibuffer
     (setq inhibit-splash-screen 0) ;; disable startup screen
     (setq ring-bell-function 'ignore) ;; don't make a sound
     (defalias 'yes-or-no-p 'y-or-n-p) ;; instead of yes/no ask y/n
     )
 #+END_SRC
*** Some informative numbers
#+BEGIN_SRC emacs-lisp
   (use-package display-line-numbers
     :config
     (global-display-line-numbers-mode +1))
   (use-package simple
     :config
     (column-number-mode +1))
#+END_SRC
*** Some cursor tweaks
#+BEGIN_SRC emacs-lisp
   (use-package emacs
     :config
     (setq-default cursor-type 'bar))
   (use-package frame
     :config
     (blink-cursor-mode -1))
   (use-package hl-line
     :config
     (global-hl-line-mode +1))

 #+END_SRC
*** Interactive Edit(IEdit)
 Edit multiple occurrences of a text.
 #+BEGIN_SRC emacs-lisp
   (use-package iedit
		:straight t
		:bind (("C-;" . 'iedit-mode)))
 #+END_SRC
*** Interactive Buffer Management
Ibuffer is a built in Emacs package that helps you manage your open buffers a in a interactively
designed interface.
#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :bind (("C-x C-b" . 'ibuffer)))
#+END_SRC
=Ibuffer-projectile= provides ibuffer integration with projectile to seperate buffers that belong
to different git repos in the Ibuffer view.
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-projectile 
    :straight t
    :hook (ibuffer . ibuffer-projectile-set-filter-groups))

#+END_SRC
*** Multiple Cursors
 For scenarios that IEdit does not work we are going to use Multiple cursors.
 #+BEGIN_SRC emacs-lisp
 (use-package multiple-cursors
   :straight t
   :bind (("C->" . 'mc/mark-next-like-this)
	  ("C-<" . 'mc/mark-previous-like-this)
	  ("C-c C-<" . 'mc/mark-all-like-this)
	  ("C-M-," . 'mc/edit-lines)))
 #+END_SRC
*** Jump to defenition
 Although we are going to setup LSP (Language Server Protocol) and that provides so many features
 like jump to defenition but for simpler use cases we can use =dumb jump= which provide jump to 
 defenition feature using rg/ag.
 #+BEGIN_SRC emacs-lisp
   (use-package dumb-jump
     :straight t
     :bind
     (("C-M-j" . 'dumb-jump-go)
      ("C-M-p" . 'dumb-jump-back))
     :config
     (dumb-jump-mode 1))
 #+END_SRC
*** Highlight TODOs
 Highlight TODO/FIXME/... in text.
 #+BEGIN_SRC emacs-lisp
 (use-package hl-todo
   :straight t
   :hook ((prog-mode) . hl-todo-mode)
   :config
   (setq hl-todo-highlight-punctuation ":"
	 hl-todo-keyword-faces
	 `(("TODO"       warning bold)
	   ("FIXME"      error bold)
	   ("HACK"       font-lock-constant-face bold)
	   ("REVIEW"     font-lock-keyword-face bold)
	   ("NOTE"       success bold)
	   ("DEPRECATED" font-lock-doc-face bold))))
 #+END_SRC
*** Expand Region
 A selected text is called region in Emacs, expand region helps you expand this region based
 semantics.
 #+BEGIN_SRC emacs-lisp
   (use-package expand-region
     :straight t
     :bind (("C-=" . 'er/expand-region)
	    ("C--" . 'er/contract-region)))
 #+END_SRC
*** Sudo Edit
 Edit root owned files in emacs without restarting Emacs.
 #+BEGIN_SRC emacs-lisp
   (use-package sudo-edit
		:commands (sudo-edit))
 #+END_SRC
*** Highlight Indents
 #+BEGIN_SRC emacs-lisp
 (use-package highlight-indent-guides
   :hook ((yaml-mode) . highlight-indent-guides-mode)
   :init
   (setq highlight-indent-guides-method 'character)
   :config
   (add-hook 'focus-in-hook #'highlight-indent-guides-auto-set-faces))
 #+END_SRC
*** Improve Scrolling
 #+BEGIN_SRC emacs-lisp
   (use-package emacs
     :custom
     ; vertical scrolling
     (scroll-step 1)
     (scroll-margin 1)
     (scroll-conservatively 101)
     (scroll-up-aggressively 0.01)
     (scroll-down-aggressively 0.01)
     (auto-window-vscroll nil)
     (fast-but-imprecise-scrolling nil)
     (mouse-wheel-scroll-amount '(1 ((shift) . 1)))
     (mouse-wheel-progressive-speed nil)
     ;; Horizontal Scroll
     (hscroll-step 1)
     (hscroll-margin 1))
 #+END_SRC
*** Which key
Now you probably agree with me that Emacs has a lot of keybindings and sometimes you just feel
lost, that's when which key comes in, when you just remember part of keybinding which shows you a
prompt of available options and their respective functionality.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :straight t
    :custom
    (which-key-idle-delay 0.3)
    :config
    (which-key-mode 1))
#+END_SRC
*** Crux (useful elisp functions)
#+BEGIN_SRC emacs-lisp
(use-package crux
  :straight t
  :config
  (require 'crux)
  :bind (("C-S-k" . 'crux-kill-whole-line))
  ("C-x K" . 'crux-kill-other-buffers))

#+END_SRC
*** Dumb Jump
Sometimes when you are dealing with really big projects LSP can feel a little slow so that's
when dumb jump can help you jump to defenitions using Rg or ag or grep (we use Rg)
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump

  :straight t
  :bind
  (("C-M-j" . 'dumb-jump-go)
   ("C-M-p" . 'dumb-jump-back))
  :config
  (dumb-jump-mode 1))
#+END_SRC
*** Org Mode
***** Org
#+BEGIN_SRC emacs-lisp
  (use-package org
  :straight t
  :demand
  :init
  (defun amirreza/--org-insert-elisp-code-block () 
    (interactive)
    (insert (format "#+begin_src emacs-lisp\n\n#+end_src"))
    (previous-line)
    (beginning-of-line))
  :bind (:map org-mode-map
              ("C-c c b" . amirreza/--org-insert-elisp-code-block))
  :custom
  (org-ellipsis "⤵")
  (org-src-fontify-natively t)
  (org-src-tab-acts-natively t)
  (org-support-shift-select t)
  (org-src-window-setup 'current-window))
#+END_SRC
***** Org bullets
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :straight t
  :hook (org-mode . org-bullets-mode))
#+END_SRC
*** Engine Mode
#+BEGIN_SRC emacs-lisp
(use-package engine-mode :straight t :defer t)
#+END_SRC
*** Windows
 Emacs by default has no notion of tabs (like the other IDEs) but it has the more powerful
 notion of windows and buffers, you already know about buffers, but windows are a way of displaying 
 buffers side by side in the screen, look at windows like tmux panes (if I'm correct) or vim splits.
**** Window rules
Emacs windows can be configured in the matter of where their gonna open.
#+BEGIN_SRC emacs-lisp

#+END_SRC
**** Winner (Restore Window layout)
 When we are working with multiple windows open but we might maximize one window to focus
 on it, but when we are done with focus mode ;) we need that layout back that's were winner mode
 comes handy you can restore last window layout with just a function called =winner-undo= that
 by default is bound to =C-c <left>=.
 #+BEGIN_SRC emacs-lisp
   (use-package winner 
     :commands (winner-redo winner-undo))
 #+END_SRC
**** Ace Window (Better Window Management)
 #+BEGIN_SRC emacs-lisp
 (use-package ace-window
   :straight t
   :bind (("C-x o" . 'ace-window) 
	  ("C-x C-o" . 'ace-window)))
 #+END_SRC
*** Completion
**** General Completion
When you are typing in minibuffer forexample after hitting M-x when user hits tab Emacs shows 
available options to them in a another window opened but wans't it nice if we had better interface for that
since Emacs already knows the available options ? well there is and that's called wait for it
well actually there are multiple package for this purpose but since we are going as minimal as possible 
***** Icomplete
 #+BEGIN_SRC emacs-lisp
   (use-package icomplete
     :disabled t
     :demand ; loading of icomplete is not deferred since we are using `:bind'.
     :custom
     (icomplete-max-delay-chars 0)
     (icomplete-compute-delay 0)
     (icomplete-show-matches-on-no-input t) ;; show completions from start of entering the minibuffer
     (icomplete-separator " . ") ;; seperator of candidates
     (icomplete-hide-common-prefix nil) ;;
     (icomplete-with-completion-tables t) ;; do completion on anything that has a completion table
     (icomplete-in-buffer nil) ; we dont want icomplete to work in buffers, we have company for that
     :bind (:map icomplete-minibuffer-map
                 ("C-f" . icomplete-forward-completions)
                 ("C-b" . icomplete-backward-completions)
                 ("C-n" . icomplete-forward-completions)
                 ("C-p" . icomplete-backward-completions)
                 ("<right>" . icomplete-forward-completions)
                 ("<left>" . icomplete-backward-completions)
                 ("<up>" . icomplete-backward-completions)
                 ("<down>" . icomplete-forward-completions))
     :config
     (if (> emacs-major-version 26) ;; Emacs 27 and up
         (fido-mode +1) ;; Fido (fake ido) emulates a IDO like interface for icomplete.
       (icomplete-mode +1)))
  (use-package icomplete-vertical
    :straight (:host github :repo "oantolin/icomplete-vertical")
    :config
    (icomplete-vertical-mode 1))
 #+END_SRC
***** IDO
=SideNote=: I moved to =icomplete= since it's simpler and easier for me to customize.
 IDO is another Emacs built in way of doing completion in mini buffer.
 #+BEGIN_SRC emacs-lisp
   (use-package ido
     :disabled t
     :config
     (ido-mode 1)
     (ido-everywhere 1)
     (setq ido-enable-flex-matching t))

   (use-package ido-vertical-mode
     :disabled t
     :config
     (ido-vertical-mode 1)
     (setq ido-vertical-define-keys 'C-n-and-C-p-only))

   (use-package ido-completing-read+
     :disabled t
     :config
     (ido-ubiquitous-mode 1))

 #+END_SRC
***** Ivy
=SideNote=: I moved to =icomplete= since it's simpler and easier for me to customize.
Ivy is an amazing package that enhances several aspects of Emacs using counsel functions.
 #+BEGIN_SRC emacs-lisp
   (use-package ivy

     :straight t
     :custom
     (ivy-height 17)
     (ivy-wrap t)
     (ivy-fixed-height-minibuffer t)
     (projectile-completion-system 'ivy)
     ;; disable magic slash on non-match
     (ivy-magic-slash-non-match-action nil)
     ;; don't show recent files in switch-buffer
     (ivy-use-virtual-buffers nil)
     ;; ...but if that ever changes, show their full path
     (ivy-virtual-abbreviate 'full)
     ;; don't quit minibuffer on delete-error
     (ivy-on-del-error-function #'ignore)
     ;; enable ability to select prompt (alternative to `ivy-immediate-done')
     (ivy-use-selectable-prompt t)
     :config
     (setf (alist-get 't ivy-format-functions-alist)
           #'ivy-format-function-line)
     (ivy-mode +1)
     :bind
     (("C-x b" . 'ivy-switch-buffer)))

   (use-package swiper
     :straight t

     :commands (swiper)
     :init (global-set-key (kbd "C-s") 'swiper))

   (use-package counsel

     :straight t
     :commands (counsel-M-x counsel-find-file ivy-switch-buffer)
     :bind
     (("M-x" . 'counsel-M-x)
      ("C-x C-f" . 'counsel-find-file)
      ("C-h b" . 'counsel-descbinds)
      ("C-h f" . 'counsel-describe-function)
      ("C-h v" . 'counsel-describe-variable)
      ("C-h a" . 'counsel-apropos)
      ("<f6> s" . 'counsel-rg)
      ("<f6> f" . 'counsel-fzf)
      ( "M-y" . 'counsel-yank-pop)))
 #+END_SRC
**** In Buffer Completion
Code completion consists of two parts, A source/server that provides the completions and 
an engine that knows when to open prompt and show the completions. We will configure servers later
but now we need to install the engine that shows us the completion.
=Company-mode= in my opinion is the best one out there, it consists of =backends= and =frontends=
backends connect to multiple tools that provide the completions and frontends are about the GUI.
Since we are going to use LSP as the main source for the completions we just need the default 
configuration of company.
For company backends we are going to use =company-capf= which is abbrv for =company complete at point function= which is a function in Emacs that major modes
can call an get completions based on that.
#+BEGIN_SRC emacs-lisp
    (use-package company
      :demand
      :straight t
      :custom
      (company-tooltip-limit 30)
      (company-idle-delay .1)
      (company-echo-delay 0.1)
      (company-backends '(company-capf company-dabbrev company-files company-dabbrev-code))
      :bind (:map company-active-map
                  ("C-n" . company-select-next)
                  ("C-p" . company-select-previous)
                  ("C-o" . company-other-backend)
                  ("<tab>" . company-complete-common-or-cycle))
      :config
      (defmacro amirreza/with-backends (mode backends) 
        "Register a buffer local variable with given BACKENDS for given MODE. For registering backends for various modes use this"
        (let ((mode-hook (intern (concat (symbol-name mode) "-hook"))))
          (message "amirreza/with-backends called with %s %s %s" mode backends mode-hook)
          `(add-hook (quote ,mode-hook) (lambda ()
                                          (setq-local company-backends (quote ,backends))
                                          ))))
      (global-company-mode t)
      )


#+END_SRC
***** Company Tabnine
Tabnine is a completion engine that uses machine learning on source code to find the candidates for the auto completion.
#+begin_src emacs-lisp
  (use-package company-tabnine :straight t :after company :hook company)
#+end_src
*** Searching
There are two tools that I think are amazing when it comes to searching, for text =ripgrep= is
the fastest and easiest one out there, and for files is =FZF=, let's integrate those two in Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package isearch
    :custom
    (isearch-highlight t)
    (isearch-whitespace-regexp ".*?")
    (isearch-lax-whitespace t)
    (isearch-regexp-lax-whitespace nil)
    (isearch-lazy-highlight t))
  (use-package fzf
    :straight t
    :bind
    (("<f6> f" . fzf)))
  (use-package rg
    :straight t
    :bind (("<f6> s" . rg)))
#+END_SRC
*** Rainbow delimiters
Highlight matching brackets in matching colors
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters :straight t :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
*** Rainbow Blocks
although =Rainbow-delimiters= shows us the start and end of an list, but it's nice to be able to see more.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-blocks :straight t)
#+END_SRC
* Integrated Development Environment
IDE means =Integrated Development Environment= basically a software provides you with every thing you need when you are developing software, and since Emacs is such a extensible platform
turning Emacs into an IDE is not that hard.
*** Terminal Emulator
Terminal emulator (don't mistake it with a shell like zsh or bash) is one of the core parts of my development environment and I have tried
multiple Emacs solutions and none of them actually fit my needs until I found =vterm=. You are going to need =CMake=, =libtool= for this to
be able to work since it's actually using C for it's core.
#+BEGIN_SRC emacs-lisp
  (use-package vterm 
    :straight t
    :commands vterm
    :bind (("<f10>" . vterm))
    :config
    (defun amirreza/vterm-hooks () 
      (display-line-numbers-mode -1))
    (add-hook 'vterm-mode-hook 'amirreza/vterm-hooks))
#+END_SRC
*** Language Server Protocol

Language Server protocol is a open source protocol developed by microsoft but now it's being
developed by community, it defines a communication protocol that a lanaguge server (let's say gopls)
can talk to various clients (let's say Emacs, Vi, VSCode) and provide several features such
as auto-complete or syntax linting.
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode 
    :straight t
    :commands (lsp lsp-deferred)
    :hook 
    ((python-mode
      go-mode) . lsp)
    :custom
    (lsp-auto-guess-root t)
    :commands (lsp))
#+END_SRC
LSP-ui is a mode from the same author with the goal of configuring several Emacs packages to 
help ease developer experience when using LSP.
#+BEGIN_SRC emacs-lisp
(use-package lsp-ui :straight t :commands lsp-ui-mode :hook (lsp-mode . lsp-ui-mode))
#+END_SRC
*** Git integration
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :straight t
    :commands (magit-status)
    :general 
    (space-leader "g s" 'magit-status)
    :bind
    (("C-x g" . 'magit-status)))

  (use-package diff-hl
    :straight t
    :config (global-diff-hl-mode 1))

  (use-package
    gitconfig-mode
    :straight t
    :mode "/\\.gitconfig\\'")

  (use-package gitignore-mode
    :straight t
    :mode "/\\.gitignore\\'")

  (use-package gitattributes-mode
    :straight t
    :mode "/\\.gitattributes\\'")

  (use-package git-messenger
    :straight t
    :bind
    (("<f1> g" . 'git-messenger:popup-message))
    :config
    (setq git-messenger:show-detail t)
    (setq git-messenger:use-magit-popup t))

#+END_SRC
*** Syntax checking
Emacs comes with a built in syntax checker called =flymake=, but since emacs community favors =flycheck= over =flymake= we are going to setup flycheck.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :straight t
    :hook (prog-mode . flycheck-mode))
#+END_SRC
*** Debugger Support
TBA
*** Project Detection
=projectile= is a package that notifies when you open something in a git repository and can
provide several feature to other packages or to the user directly.
#+BEGIN_SRC emacs-lisp
(use-package projectile
       :bind
       (("C-x p" . 'projectile-command-map)
        ("C-c p" . 'projectile-add-known-project))
       :config
       (projectile-mode 1))

#+END_SRC
* Programming Languages
** Python
*** Python Mode
Emacs itself comes with =python-mode= which is python major mode that provides emacs with 
syntax highlighting and some other features on python, so we just need to configure it the way 
we want. I added some custom python functions to suit my python needs like the docstring function
that inserts a docstring in python syntax.
#+BEGIN_SRC emacs-lisp
  (use-package python-mode
    :mode "\\.py\\'"
    :config
    (defun amirreza/python-insert-docstring ()
      (interactive)
      (insert "'''\n'''")
      (previous-line))
    (amirreza/with-backends python-mode (company-capf))
    :bind
    (:map python-mode-map 
      ("C-c l p d" . amirreza/python-insert-docstring)))
#+END_SRC
*** Microsoft Language Server
#+begin_src emacs-lisp
(use-package lsp-python-ms :straight t)
#+end_src
*** Pipenv
=Pipenv= is now the de facto tool for python programmers to manage their project deps, so it's nice
to have a wrapper for it in Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package pipenv
	       :straight t
	       :defer t)
#+END_SRC
*** Py-autopep8
We are using LSP for all our IDE like features but right now python lanugage server does not
provide formmatting feature for python so we need to use another package called =py-autopep8= which
actually is just a wrapper around python package that you need to install from =pypi= called 
no suprises =py-autopep8=. We install this package and we need this package to hook it's format 
function to =before-save-hook= of emacs, luckily this package provides a helper function to do that.
#+BEGIN_SRC emacs-lisp
(use-package py-autopep8
  :straight t
  :hook python-mode
  :config
  (py-autopep8-enable-on-save))

#+END_SRC
** Go
*** Go-mode
Golang by default is not supported in Emacs, but don't fear, we can fix that by simply installing
=go-mode= which is a major mode and it provides the basic syntax highlighting that we need, we also
need to configure this package to enable some LSP features that are necessary like formatting. For
go to work perfectly you need to add the =GOPATH= to your =exec-path= to let emacs find go binaries
that it needs.
#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :straight t
    :mode ("\\.go\\'" . go-mode)
    :init
    (add-hook 'go-mode-hook (lambda () (add-to-list 'exec-path (concat (getenv "HOME") "/go/bin"))))
    :config
    (amirreza/with-backends go-mode ((company-capf company-tabnine)))
    (add-hook 'go-mode-hook (lambda () (interactive)
                              (add-hook 'before-save-hook 'lsp-format-buffer t t)
                              (add-hook 'before-save-hook 'lsp-organize-imports t t))))
#+END_SRC
*** Go-add-tags
it's always a pain to manually add struct tags for a struct specially when
the struct has so many fields, again thanks to the emacs community we have package for that 
to ease that task for us.
#+BEGIN_SRC emacs-lisp
  (use-package go-add-tags :straight t :defer t :bind (:map go-mode-map ("C-c C-g s t" . go-add-tags)))
#+END_SRC
*** Go-test
=VSCode= has a great support when it comes to running go tests, it gives you the ability to 
run a test when you are editing or viewing it but it does'nt mean that Emacs can't do that.
#+BEGIN_SRC emacs-lisp
  (use-package gotest :defer t :straight t :bind (:map go-mode-map ("C-c C-g t f" . go-test-current-file) ("C-c C-g t t" . go-test-current-test)))
#+END_SRC
** Elisp
Emacs lisp should be supported by default ha ? actually it has almost all support you need but 
we can even go further.x
#+BEGIN_SRC emacs-lisp
  (use-package elisp-mode
    :config
    (defun --amirreza/emacs-lisp-repeat (str count)
      "Create dashes with given COUNT."
      (let ((dashes ""))
	(dotimes (iterator count dashes)
	  (setq dashes (concat dashes str)))))

    (defun --amirreza/emacs-lisp-wrap-text-in-spaces (text)
      (let* ((len (length text))
	     (spaces-length-side (/ (- 80 len) 2))
	     (spaces-side (--amirreza/emacs-lisp-repeat " " spaces-length-side)))
	(format "%s%s%s" spaces-side text spaces-side)))

    (defun amirreza/emacs-lisp-insert-comment-line (text)
      "Insert a comment line with given TEXT."
      (interactive "sComment: ")
      (let* ((text-wrapped (--amirreza/emacs-lisp-wrap-text-in-spaces text))
	     (dashes (--amirreza/emacs-lisp-repeat "=" 80)))
	(insert (format "\n;;%s\n;;%s\n;;%s" dashes text-wrapped dashes))))
    :bind
    (:map emacs-lisp-mode-map
	  ("C-c C-c C-d" . 'amirreza/emacs-lisp-insert-comment-line)))

#+END_SRC
** Clojure
*** Clojure Mode
    #+BEGIN_SRC emacs-lisp
      (use-package clojure-mode :straight t)
    #+END_SRC
*** Cider
#+BEGIN_SRC emacs-lisp
  (use-package cider 
    :straight t
    :commands (cider cider-jack-in)
    )
#+END_SRC
** Common Lisp
*** Common-lisp mode
#+BEGIN_SRC emacs-lisp
(use-package lisp-mode :mode "\\.cl\\'")
#+END_SRC
*** Common Lisp Integrated Environment
#+BEGIN_SRC emacs-lisp
(use-package sly :straight t)
#+END_SRC
** Haskell
*** Haskell mode
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode :straight t :mode "\\.hs\\'")
#+END_SRC
*** Haskell IDE engine
#+BEGIN_SRC emacs-lisp
(use-package lsp-haskell :straight t :hook haskell-mode)
#+END_SRC
** HTML/CSS
#+BEGIN_SRC emacs-lisp
  (use-package web-mode :straight t :mode ("\\.html\\'" "\\.css\\'"))
#+END_SRC
** PHP
*** PHP mode
#+BEGIN_SRC emacs-lisp
(use-package php-mode :straight t :mode "\\.php\\'")
#+END_SRC
*** PHP Runtime Integration
#+BEGIN_SRC emacs-lisp
(use-package php-runtime :straight t :defer t)
#+END_SRC
*** Composer Integration
#+BEGIN_SRC emacs-lisp
(use-package composer :straight t :hook php-mode)
#+END_SRC
*** PHPUnit
#+BEGIN_SRC emacs-lisp
(use-package phpunit :straight t :commands (php-current-test php-current-class php-current-project))
#+END_SRC
** Rust
*** Rust mode
#+BEGIN_SRC emacs-lisp
(use-package rust-mode :straight t :mode "\\.rs\\'")
#+END_SRC
* Devops
*** Docker
#+BEGIN_SRC emacs-lisp
(use-package docker-compose-mode
  :straight t
  :defer t)
#+END_SRC
*** Kubernetes
#+begin_src emacs-lisp
(use-package kubel :straight t :commands (kubel) :bind (("<f9>" . kubel)))
#+end_src
