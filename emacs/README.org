#+TITLE: AmirrezaAsk Integrated Computing Environment
#+AUTHOR: amirrezaask
* Table Of contents                                                     :TOC@4:
- [[#intro][Intro]]
- [[#personal-information][Personal information]]
- [[#emacs-internals-optimizations][Emacs internals optimizations]]
  - [[#gc][GC]]
  - [[#file-name-handler-alist][file-name-handler-alist]]
- [[#package-manager-setup][Package manager setup]]
- [[#keybinding][Keybinding]]
- [[#basic-setups][Basic setups]]
  - [[#edit-configuration-shortcut][Edit configuration shortcut]]
- [[#ui][UI]]
  - [[#themes][Themes]]
  - [[#some-cursor-tweaks][Some cursor tweaks]]
  - [[#modeline][Modeline]]
- [[#font][Font]]
- [[#minibuffer][Minibuffer]]
  - [[#icomplete][Icomplete]]
  - [[#ivy][Ivy]]
- [[#windowsworkspaces][Windows/Workspaces]]
  - [[#window-rules][Window rules]]
  - [[#eyebrowse][Eyebrowse]]
  - [[#winner-restore-window-layout][Winner (Restore Window layout)]]
  - [[#ace-window-better-window-management][Ace Window (Better Window Management)]]
- [[#buffer-management][Buffer management]]
  - [[#ibuffer][IBuffer]]
- [[#editing][Editing]]
  - [[#motions][Motions]]
    - [[#custom-motions][Custom motions]]
    - [[#avy][Avy]]
  - [[#highlight-indentation][Highlight indentation]]
  - [[#sudo-edit][Sudo edit]]
  - [[#expand-region][Expand region]]
  - [[#highlight-todofixme][Highlight TODO/FIXME/...]]
  - [[#multiple-cursors][Multiple cursors]]
  - [[#iedit][Iedit]]
  - [[#vlf-very-large-file][Vlf (very large file)]]
  - [[#so-long-lines][So Long lines]]
- [[#writing][Writing]]
  - [[#org][Org]]
    - [[#org-bullets][Org bullets]]
    - [[#org-toc][Org TOC]]
    - [[#htmlize][htmlize]]
  - [[#markdown-mode][Markdown mode]]
- [[#searching][Searching]]
  - [[#in-buffer-searching][In Buffer searching]]
  - [[#grep][Grep]]
- [[#file-search][File search]]
  - [[#recents][Recents]]
  - [[#projects-integration][Projects Integration]]
- [[#shells][Shells]]
      - [[#eshell][Eshell]]
      - [[#vterm][VTerm]]
- [[#development][Development]]
  - [[#completion][Completion]]
  - [[#code-semantic-movement][Code Semantic Movement]]
  - [[#snippets][Snippets]]
  - [[#dumb-jump][Dumb Jump]]
  - [[#language-server-protocol][Language Server Protocol]]
  - [[#rainbow-delimiters][Rainbow delimiters]]
  - [[#syntax-checking][Syntax checking]]
  - [[#docs][Docs]]
  - [[#languages][Languages]]
    - [[#python][Python]]
      - [[#python-mode][Python Mode]]
      - [[#microsoft-language-server][Microsoft Language Server]]
      - [[#pipenv][Pipenv]]
      - [[#py-autopep8][Py-autopep8]]
    - [[#go][Go]]
      - [[#go-mode][Go-mode]]
      - [[#go-add-tags][Go-add-tags]]
      - [[#go-test][Go-test]]
    - [[#scheme][Scheme]]
    - [[#zig][Zig]]
    - [[#lisp-configuration][Lisp configuration]]
    - [[#emacs-lisp][Emacs lisp]]
    - [[#clojure][Clojure]]
      - [[#clojure-mode][Clojure Mode]]
      - [[#cider][Cider]]
    - [[#common-lisp][Common Lisp]]
      - [[#common-lisp-mode][Common-lisp mode]]
      - [[#common-lisp-integrated-environment][Common Lisp Integrated Environment]]
    - [[#haskell][Haskell]]
      - [[#haskell-mode][Haskell mode]]
      - [[#haskell-ide-engine][Haskell IDE engine]]
    - [[#htmlcss][HTML/CSS]]
    - [[#php][PHP]]
      - [[#php-mode][PHP mode]]
      - [[#php-runtime-integration][PHP Runtime Integration]]
      - [[#composer-integration][Composer Integration]]
      - [[#phpunit][PHPUnit]]
    - [[#rust][Rust]]
      - [[#rust-mode][Rust mode]]
    - [[#protobuf][Protobuf]]
- [[#vcs][VCS]]
  - [[#smerge][Smerge]]
- [[#dired][Dired]]
- [[#irc][IRC]]
- [[#process-management][Process management]]
- [[#music][Music]]
  - [[#rhythmbox][Rhythmbox]]
- [[#video][Video]]
- [[#configuration-files][Configuration files]]
- [[#tramp][Tramp]]
- [[#docker][Docker]]
- [[#kubernetes][Kubernetes]]
- [[#benchmark-startup-time][Benchmark startup time]]

* Intro
Since Emacs is becoming the tool I do all my computing in,
I call it Integrated Computing Environment. Idea of Emacs is not
to re invent every wheel that has been invented, it's the opposite actually,
find the best tools that perfectly suits your needs and integrate them in an interactive
and easy to use (for your needs).
* Personal information
#+begin_src emacs-lisp
    (setq user-full-name "AmirrezaAskarpour"
          user-mail-address "raskarpour@gmail.com")
#+end_src
* Emacs internals optimizations
:PROPERTIES:
  :header-args: :tangle no
  :END:
I moved all of the code of this part to =early-init.el=.
** GC
Emacs is a really old software, many of the default values in Emacs aren't actually suited for today's
modern computers. Emacs has a built-in Garbage collector that does garbage collection every time Emacs lisp
VM reaches a threshold of memory usage, and this garbage collector sweeps are sometimes annoying, but remember 
garbage collector threshold is a tricky setting, if you set it to low you will start experiencing a lot of GC sweeps that slow you down
and if you set it very high GC sweeps take forever to finish. Default Emacs =gc-cons-threshold= is set to =800000=
which is not really enough specially for Emacs startup since it needs to scan through all your installed packages
so we are going to increase it during startup time and then after Emacs initialization we can decrease it again.
#+begin_src emacs-lisp
  (setq gc-cons-threshold (* 1024 1024 100)) ;; 100MB for Emacs initialization process
  (add-hook 'after-init-hook (lambda ()
                               (setq gc-cons-threshold (* 1024 1024 20)))) ;; reseting the gc cons to 20MB
#+end_src
** file-name-handler-alist
Emacs has a global variable called =file-name-handler-alist=, it stores handlers for various file extensions, before =use-package= era we used to
add new file extensions to this variable to load their respective handler, On every file open, Emacs looks and scans through this variable to see if it
can find a match for given file, but during the startup process we are going to only evaluate stuff so we don't need file-handlers, as result we are going 
to set this file's value to a nil value during startup and restore it's original value after emacs initialization.
#+begin_src emacs-lisp
  (defvar file-name-handler-alist-bak file-name-handler-alist "file name handler backup.")
  (setq file-name-handler-alist nil)
  (add-hook 'after-init-hook (lambda () (setq file-name-handler-alist file-name-handler-alist-bak)))
#+end_src
* Package manager setup
#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
(straight-use-package 'use-package)
#+end_src
* Keybinding
I respect Emacs keybinding conventions in my configuration with a few ideas borrowed from spacemacs.
I used to use which-key as my helper on keybindings but now I just use ? when i'm in the middle of a key chord.
I use hydra when keybindings are just crazy like in smerge that you will see in it's own section. I used to use hydra more
extensively but now i use it only when keybindings are just crazy.
#+begin_src emacs-lisp
  (use-package hydra
    :straight t
    :commands (defhydra))

  (use-package pretty-hydra
    :straight t
    :commands (pretty-hydra-define))

  (use-package which-key
    :straight t
    :config
    (setq which-key-idle-delay 0.3)
    (defalias 'which-key! 'which-key-add-key-based-replacements)
    (which-key! "C-s-m" "Music functions")
    (which-key! "C-s-l" "Language/LSP related functionality")
    (which-key! "C-." "Multiple Cursors")
    (which-key! "C-s-v" "Version control actions")
    (which-key! "C-s-f" "File functions")
    (which-key! "C-s-w" "Workspaces")
    (which-key! "C-c o" "external tools integration")
    (which-key! "C-c d" "Docker")
    (which-key! "C-c k" "Kubernetes")
    (which-key-mode 1))
  (which-key-setup-minibuffer)

#+end_src
* Basic setups
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (setq-default
     indent-tabs-mode nil
     tab-width 4) ;; emacs tabs settings

    (setq backup-directory-alist
          '(("." . "~/.emacs.d/backup/"))) ;; put all emacs backup files in oneplace
    (setq backup-by-copying t)
    (setq version-control t)
    (setq delete-old-versions t)
    (setq kept-new-versions 6)
    (setq kept-old-versions 2)
    (setq create-lockfiles nil)

    (defalias 'yes-or-no-p 'y-or-n-p) ;; answer with y-n instead of yes-no

    (setq echo-keystrokes 0.1) ;; echo keystrokes in minibuffer faster

    (setq use-dialog-box nil) ;; ask quesions in minibuffer
    (setq inhibit-splash-screen 0) ;; disable startup screen
    (setq ring-bell-function 'ignore) ;; don't make a sound

    (set-terminal-coding-system 'utf-8) ;; default emacs encodings
    (set-keyboard-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
    (setq-default fill-column 80) ;; column number which emacs start to line wrap.

    ; vertical scrolling
    (setq scroll-step 5)
    (setq scroll-margin 5)
    (setq scroll-conservatively 101)
    (setq scroll-up-aggressively 0.11)
    (setq scroll-down-aggressively 0.01)
    (setq auto-window-vscroll nil)
    (setq fast-but-imprecise-scrolling nil)
    (setq mouse-wheel-scroll-amount '(5
                                      ((shift) . 10)))
    (setq mouse-wheel-progressive-speed t)
    ;; Horizontal Scroll
    (setq hscroll-step 1)
    (setq hscroll-margin 1))

  (use-package cus-edit
    :config
    (setq custom-file "~/.emacs.d/custom.el"))

  (use-package delsel ;; delete region when start typing
    :hook (after-init . delete-selection-mode))

  (use-package simple
    :config
    (column-number-mode +1)
    (setq kill-ring-max 15))

  (use-package battery :config (display-battery-mode 1))

  (use-package time :config (display-time-mode 1))

  (use-package display-line-numbers
    :disabled t
    :config
    (global-display-line-numbers-mode +1))

  (use-package paren 
    :config
    (show-paren-mode 1)
    (setq show-paren-delay 0))

  (use-package help-mode 
    :demand
    :bind (:map help-mode-map 
                ("n" . next-line)
                ("p" . previous-line)))
#+end_src
** Edit configuration shortcut
#+begin_src emacs-lisp
  (defun amirreza/edit-configuration ()
     (interactive)
     (find-file "~/.emacs.d/README.org"))
  (global-set-key (kbd "<f9>") 'amirreza/edit-configuration)
#+end_src
* UI
** Themes
 Now that we have use-package we can start installing thems, packages, etc. Let's start by installing some thems.
 for some time now I am using modus themes by the amazing =Protesilaos Stavrou= (btw check his youtube channel) which are simple but elegant themes
 but if you want a more modern look like =VSCode= or =Atom= you can use =doom-themes= as well.
 ([[https://github.com/hlissner/emacs-doom-themes/tree/screenshots][Doom Themes Screenshots]])
 #+BEGIN_SRC emacs-lisp
   (use-package modus-operandi-theme :straight t :defer t)
   (use-package modus-vivendi-theme :straight t :defer t)
   (use-package doom-themes :straight t :defer t)
   (use-package darkburn-theme :straight t :defer t)
 #+END_SRC
 You probably notice the =:defer= part in use-package, with =:defer= keyword (:something is called a keyword in elisp)
 use-package knows that we don't need this package to be loaded in startup, since we actually don't need all of our themes
 to be loaded at startup. Another keyword that you see is =:straight= that is telling use-package to make certain
 that this package is installed, and if it's not install it from elpa repo.
 Now let's set a theme
 #+BEGIN_SRC emacs-lisp
   (use-package emacs 
     :config 
     (setq ring-bell-function t)
     (setq visible-bell t))

   (use-package custom
     :demand
     :bind (("<f12>" . amirreza/toggle-color-mode))
     :config
     (defvar amirreza/current-mode 'dark "Current color mode of Emacs.")
     (defvar amirreza/dark-theme 'doom-one)
     (defvar amirreza/light-theme 'doom-one-light)

     (defmacro amirreza/--load-theme (&rest theme-opts)
       `(progn (mapc #'disable-theme custom-enabled-themes)
               (load-theme ,@theme-opts)))

     (defun amirreza/load-theme ()
       (interactive)
       (let ((theme (intern  (completing-read "Theme: " (mapcar #'symbol-name
                                                                (custom-available-themes))))))
                 
         (amirreza/--load-theme theme t)))
  
     (defun amirreza/apply-color (mode)
       "Apply current color mode to Emacs."
       (if (eq amirreza/current-mode 'dark)
           (amirreza/--load-theme amirreza/dark-theme t)
         (amirreza/--load-theme  amirreza/light-theme t)))

     (defun amirreza/toggle-color-mode ()
       "Toggle current mode to the opposite"
       (interactive)
       (if (eq amirreza/current-mode 'dark)
           (setq amirreza/current-mode 'light)
         (setq amirreza/current-mode 'dark))
       (amirreza/apply-color amirreza/current-mode))
    (amirreza/apply-color amirreza/current-mode))
 #+END_SRC
***** Performance Tip 
 About 95% of packages we use don't need to be loaded at startup and =:defer= is only one of the multiple
 ways of lazy-loading in use-package we will see others later on.
** Some cursor tweaks
 #+BEGIN_SRC emacs-lisp
   (use-package emacs
     :config
     (setq-default ring-bell-function 'ignore)
     (setq-default cursor-type 'bar))

   (use-package frame
     :config
     (blink-cursor-mode 1))

   (use-package hl-line
     :config
     (global-hl-line-mode +1))

  #+END_SRC
** Modeline
#+begin_src emacs-lisp
      (use-package emacs
        :disabled t
        :config
        (setq mode-line-percent-position '(-3 "%p"))
        (setq-default mode-line-format
                      '(
                        " "
                        mode-line-modified
                        " "
                        mode-line-mule-info
                        " "
                        mode-line-buffer-identification
                        " <"
                        mode-name
                        "> "
                        mode-line-position
                        " "
                        (vc-mode vc-mode))))
      (use-package doom-modeline 
        :straight t 
        :config 
        (setq doom-modeline-height 25)
        (doom-modeline-mode 1))
#+end_src
* Font
To use specific font in Emacs you just need to call a function, that's easy ha ??
#+BEGIN_SRC emacs-lisp
  (defvar amirreza/font "Fira Mono-11")
  (set-face-attribute 'default t :font amirreza/font)
  (set-frame-font amirreza/font nil t)
  (global-prettify-symbols-mode 1)
#+END_SRC
If you evaluate code above you see the font changes.
Now let's write some elisp, let's say that we want to have a function that we can call and change 
our font interactively, let's write it.
#+BEGIN_SRC emacs-lisp
  (defun amirreza/change-font (font size)
    (interactive "sFont: \nnSize: ")
    (set-face-attribute 'default t :font (format "%s-%d" font size))
    (set-frame-font (format "%s-%d" font size) nil t))
#+END_SRC
* Minibuffer
** Icomplete
#+begin_src emacs-lisp
  (use-package orderless
    :straight t
    :config
    (setq completion-styles '(orderless)))

  (use-package icomplete
    :demand
    :bind
    (:map global-map
          ("M-y" . amirreza/show-kill-ring)
          :map icomplete-minibuffer-map
          ("C-n" . icomplete-forward-completions)
          ("C-p" . icomplete-backward-completions)
          ("C-f" . icomplete-forward-completions)
          ("C-b" . icomplete-backward-completions)
          ("<right>" . icomplete-forward-completions)
          ("<left>" . icomplete-backward-completions)
          ("<down>" . icomplete-forward-completions)
          ("<up>" . icomplete-backward-completions)
          ("<RET>" . icomplete-force-complete-and-exit)
          ("<tab>" . icomplete-force-complete))
    :config
    (defun amirreza/show-kill-ring ()
      (interactive)
      (insert (completing-read "Insert: " kill-ring)))

    (setq icomplete-max-delay-chars 2
          icomplete-separator " | "
          icomplete-show-matches-on-no-input t
          icomplete-hide-common-prefix nil
          completion-ignore-case t)
    (when (> emacs-major-version 26)
      (fido-mode -1))
    (icomplete-mode 1))

  (use-package icomplete-vertical
    :straight t
    :demand
    :bind
    (:map icomplete-minibuffer-map
          ("C-v" . icomplete-vertical-toggle))
    :config
    (icomplete-vertical-mode 1))

  (use-package live-completions
    :disabled t
    :straight (:host github :repo "oantolin/live-completions")
    :config
    (live-completions-mode 1))

#+end_src
** Ivy
   :PROPERTIES:
   :header-args: :tangle no
   :END:
#+begin_src emacs-lisp
  (use-package flx :straight t)
  (use-package ivy
    :straight t
    :bind
    (("C-x b" . 'ivy-switch-buffer)
     :map ivy-minibuffer-map
     ("RET" . 'ivy-alt-done))
    :config
    (setq ivy-height 15)
    ;; loopish cycling through list
    (setq ivy-wrap t)
    ;; don't show recents in minibuffer
    (setq ivy-use-virtual-buffers nil)
    ;; ...but if that ever changes, show their full path
    (setq ivy-virtual-abbreviate 'full)
    ;; don't quit minibuffer on delete-error
    (setq ivy-on-del-error-function #'ignore)
    (setf (alist-get 't ivy-format-functions-alist)
          #'ivy-format-function-line)
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
          '((t . ivy--regex-ignore-order)))
    (ivy-mode +1))

  (use-package all-the-icons-ivy :straight t :config 
    (all-the-icons-ivy-setup))

  (use-package counsel
    :straight t
    :bind
    (("M-x" . 'counsel-M-x)
     ("C-x C-f" . 'counsel-find-file)
     ("C-h b" . 'counsel-descbinds)
     ("C-h f" . 'counsel-describe-function)
     ("C-h v" . 'counsel-describe-variable)
     ("C-h a" . 'counsel-apropos)
     ("M-i" . 'counsel-imenu) ;; code semantics
     ("M-y" . 'counsel-yank-pop))) ;; show kill ring

    (use-package ivy-rich :straight t :config (ivy-rich-mode 1))
#+end_src
* Windows/Workspaces
** Window rules
Emacs windows can be configured in the matter of where their gonna open.
#+BEGIN_SRC emacs-lisp
    (setq display-buffer-alist
          '(("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Messages\\)\\*"
               (display-buffer-in-side-window)
               (window-width . 0.40)
               (side . right)
               (slot . 0))
            ("^vterm"
              (display-buffer-in-side-window)
              (window-width . 0.40)
              (side . right)
              (slot . 0))
            ("\*eshell.*"
              (display-buffer-in-side-window)
              (window-width . 0.40)
              (side . right)
              (slot . 0))
            ("\\*rg"
              (display-buffer-in-side-window)
              (window-width . 0.50)
              (side . right)
              (slot . 0))))
#+END_SRC
** Eyebrowse
=Eyebrowse= gives you =i3= like experience in Emacs, let's you have multiple workspaces and switch between them.
#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse :straight t
    :commands (eyebrowse-close-window-config
               eyebrowse-create-window-config
               eyebrowse-switch-to-window-config-0
               eyebrowse-switch-to-window-config-1
               eyebrowse-switch-to-window-config-2
               eyebrowse-switch-to-window-config-3
               eyebrowse-switch-to-window-config-4
               eyebrowse-switch-to-window-config-5
               eyebrowse-switch-to-window-config-6
               eyebrowse-switch-to-window-config-7
               eyebrowse-switch-to-window-config-8
               eyebrowse-switch-to-window-config-9)

    :config (eyebrowse-mode +1)
    :bind (("C-c w 0" . eyebrowse-switch-to-window-config-0)
           ("C-c w 1" . eyebrowse-switch-to-window-config-1)
           ("C-c w 2" . eyebrowse-switch-to-window-config-2)
           ("C-c w 3" . eyebrowse-switch-to-window-config-3)
           ("C-c w 4" . eyebrowse-switch-to-window-config-4)
           ("C-c w 5" . eyebrowse-switch-to-window-config-5)
           ("C-c w 6" . eyebrowse-switch-to-window-config-6)
           ("C-c w 7" . eyebrowse-switch-to-window-config-7)
           ("C-c w 8" . eyebrowse-switch-to-window-config-8)
           ("C-c w 9" . eyebrowse-switch-to-window-config-9)
           ("C-c w n" . eyebrowse-create-window-config)
           ("C-c w c" . eyebrowse-close-window-config)

           ("C-s-0" . eyebrowse-switch-to-window-config-0)
           ("C-s-1" . eyebrowse-switch-to-window-config-1)
           ("C-s-2" . eyebrowse-switch-to-window-config-2)
           ("C-s-3" . eyebrowse-switch-to-window-config-3)
           ("C-s-4" . eyebrowse-switch-to-window-config-4)
           ("C-s-5" . eyebrowse-switch-to-window-config-5)
           ("C-s-6" . eyebrowse-switch-to-window-config-6)
           ("C-s-7" . eyebrowse-switch-to-window-config-7)
           ("C-s-8" . eyebrowse-switch-to-window-config-8)
           ("C-s-9" . eyebrowse-switch-to-window-config-9)
           ("C-s-w n" . eyebrowse-create-window-config)
           ("C-s-w c" . eyebrowse-close-window-config)))

#+END_SRC
** Winner (Restore Window layout)
When we are working with multiple windows open but we might maximize one window to focus
on it, but when we are done with focus mode ;) we need that layout back that's were winner mode
comes handy you can restore last window layout with just a function called =winner-undo= that
by default is bound to =C-c <left>=.
#+BEGIN_SRC emacs-lisp
  (use-package winner
    :demand
    :config
    (winner-mode 1)
    :commands (winner-redo winner-undo)
    :bind (("C->" . winner-redo)
           ("C-<" . winner-undo)))
#+END_SRC
** Ace Window (Better Window Management)
#+BEGIN_SRC emacs-lisp
      (use-package ace-window
        :straight t
        :commands (ace-window)
        :bind (("C-x C-o" . 'ace-window)))
#+END_SRC
* Buffer management
** IBuffer
#+begin_src emacs-lisp
  (use-package ibuffer
    :bind (("C-x C-b" . 'ibuffer)))

  (use-package ibuffer-vc :straight t
    :hook (ibuffer-mode . (lambda () (interactive) (ibuffer-vc-set-filter-groups-by-vc-root))))

#+end_src
* Editing
** Motions
*** Custom motions
#+begin_src emacs-lisp
  (global-set-key (kbd "M-n") 
                  (lambda ()
                    (interactive)
                    (next-line 10)))
  (global-set-key (kbd "M-p") (lambda () (interactive) (previous-line 10)))
#+end_src
*** Avy
 #+begin_src emacs-lisp
   (use-package avy :straight t
     :commands (avy-goto-char avy-goto-char-2 avy-goto-line avy-goto-word-1)
     :bind (("C-; l" . avy-goto-line)
            ("C-; w" . avy-goto-word-1)
            ("C-; c 2" . avy-goto-char-2)
            ("C-; c 1" . avy-goto-char)))
 #+end_src
** Highlight indentation
#+begin_src emacs-lisp
 (use-package highlight-indent-guides
   :straight t
   :hook ((yaml-mode) . highlight-indent-guides-mode)
   :init
   (setq highlight-indent-guides-method 'character)
   :config
   (add-hook 'focus-in-hook #'highlight-indent-guides-auto-set-faces))
#+end_src
** Sudo edit
#+begin_src emacs-lisp
   (use-package sudo-edit
        :straight t
        :commands (sudo-edit))
#+end_src
** Expand region
#+begin_src emacs-lisp
   (use-package expand-region
     :straight t
     :bind (("C-=" . 'er/expand-region)
	    ("C--" . 'er/contract-region)))
#+end_src
** Highlight TODO/FIXME/...
#+begin_src emacs-lisp
 (use-package hl-todo
   :straight t
   :hook ((prog-mode) . hl-todo-mode)
   :config
   (setq hl-todo-highlight-punctuation ":"
	 hl-todo-keyword-faces
	 `(("TODO"       warning bold)
	   ("FIXME"      error bold)
	   ("HACK"       font-lock-constant-face bold)
	   ("REVIEW"     font-lock-keyword-face bold)
	   ("NOTE"       success bold)
	   ("DEPRECATED" font-lock-doc-face bold))))
#+end_src
** Multiple cursors
#+begin_src emacs-lisp
      (use-package multiple-cursors
        :straight t
        :commands (mc/edit-lines
          mc/mark-all-like-this
          mc/mark-next-like-this
          mc/skip-to-next-like-this
          mc/unmark-next-like-this
          mc/mark-previous-like-this
          mc/skip-to-previous-like-this
          mc/unmark-previous-like-this
          mc/mark-all-in-region-regexp
          mc/insert-numbers
          mc/insert-letters)
        :bind (("C-. n" .  mc/mark-next-like-this)
               ("C-. p" . mc/mark-previous-like-this)
               ("C-. a" . mc/mark-all-like-this)))
#+end_src
** Iedit
#+begin_src emacs-lisp
  (use-package iedit
       :straight t
       :defer t)
#+end_src
** Vlf (very large file)
#+begin_src emacs-lisp
(use-package vlf :straight t :commands (vlf))
#+end_src
** So Long lines
#+begin_src emacs-lisp
  (use-package so-long 
    :config (global-so-long-mode 1))
#+end_src
* Writing
** Org
#+BEGIN_SRC emacs-lisp
  (use-package org
  :demand
  :init
  (defun amirreza/--org-insert-elisp-code-block ()
    (interactive)
    (insert (format "#+begin_src emacs-lisp\n\n#+end_src"))
    (previous-line)
    (beginning-of-line))
  :bind (:map org-mode-map
              ("C-c c b" . amirreza/--org-insert-elisp-code-block))
  :config
  (setq org-ellipsis "⤵")
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-support-shift-select t)
  (setq org-src-window-setup 'current-window)
  (setq org-agenda-files '("~/org/work.org" "~/org/personal.org")))
#+END_SRC
*** Org bullets
 #+BEGIN_SRC emacs-lisp
 (use-package org-bullets
   :straight t
   :hook (org-mode . org-bullets-mode))
 #+END_SRC
*** Org TOC
 #+begin_src emacs-lisp
 (use-package toc-org :straight t :hook (org-mode . toc-org-mode))
 #+end_src

*** htmlize
 #+begin_src emacs-lisp
 (use-package htmlize :straight t :defer t)
 #+end_src
** Markdown mode
#+begin_src emacs-lisp
(use-package markdown-mode
  :straight t
  :mode ("\\.md$" . markdown-mode))
#+end_src
* Searching
** In Buffer searching
#+begin_src emacs-lisp
  (use-package swiper
    :straight t
    :commands (swiper)
    :init (global-set-key (kbd "C-s") 'swiper))
#+end_src
** Grep
#+begin_src emacs-lisp

  (use-package rg 
    :straight t 
    :commands (rg)
    :config
    (defun amirreza/rg (pattern filetype)
      (interactive "sPattern: \nsFiletype:")
      (let* ((project (vc-root-dir))
             (dir (if project project default-directory)))
          (rg-run pattern filetype dir)))
    :bind
    (:map global-map
          ("C-c g" . amirreza/rg)
          ("C-s-g" . amirreza/rg)))
#+end_src
* File search
** Recents
 #+begin_src emacs-lisp
   (use-package counsel
     :init
     (defun amirreza/recents ()
       (interactive)
       (completing-read "Recent: " recentf-list))
  
     :bind (("C-c r" . amirreza/recents)
            ("C-s-r" . amirreza/recents)))
 #+end_src
** Projects Integration
#+begin_src emacs-lisp
  (require 'cl-lib)
  (use-package project
    :bind (("C-s-f" . amirreza/project-or-dir-find-file-recur)
           ("C-s-p" . amirreza/projects-list))

    :config
    (defun amirreza/project-or-dir-find-file-recur ()
      (interactive)
      (let* ((project (vc-root-dir))
             (dir (if project project default-directory))
             (files (directory-files-recursively dir ".*" nil (lambda (name)
                                                            (not (string-match "\\.git" name))
                                                            ) t)))
        (find-file (completing-read "Find: " files))))

    (defvar amirreza/project-locations '("~/w" "~/w/snapp" "~/w"))

    (defun amirreza/projects-list ()
      "List of projects in pre defined project locations."
      (interactive)
      (let ((proj-dirs '()))
        (mapc (lambda (dir)
                (mapc (lambda (file)
                        (add-to-list 'proj-dirs (abbreviate-file-name file )))
                      (directory-files dir t directory-files-no-dot-files-regexp)))
              amirreza/project-locations)
        (dired (completing-read "Project: " proj-dirs)))))

#+end_src
* Shells
Emacs has a bultin shell called =eshell= which uses elisp
as it's scripting engine, I use that as my main shell over the day
but for some rare situations I have VTerm that emulates a normal terminal
and use fish in that. but before anything let's update emacs exec-path to be able to find 
all executables.
#+begin_src emacs-lisp
  (use-package exec-path-from-shell 
    :straight t 
    :defer 1
    :config
    (setq exec-path-from-shell-shell-name "zsh")
    (exec-path-from-shell-initialize))
#+end_src
**** Eshell
#+begin_src emacs-lisp
  (use-package ffap)
  (require 'cl-lib)
  (use-package eshell 
    :config
    (defvar amirreza/--eshells-state (make-hash-table))

    (defun amirreza/eshell-new ()
      "Looks in the eshell state map if there is an open eshell in the current directory just switch to it,
  otherwise create a new eshell process and update the state."
      (interactive)
      (let* ((buff-ref (gethash default-directory amirreza/--eshells-state nil))
            (buff-live? (buffer-live-p buff-ref)))
        (if (and buff-ref buff-live?)
            (switch-to-buffer-other-window buff-ref)
          (progn
            (let ((new-buff (eshell 'N)))
              (puthash default-directory new-buff amirreza/--eshells-state)

              (switch-to-buffer-other-window new-buff)
              (rename-buffer (format "*eshell:%s*" default-directory)))))))

    :bind (("s-<enter>" . amirreza/eshell-new)
           ("<f11>" . amirreza/eshell-new)))

  (use-package esh-mode
    :config
    (defun amirreza/--minify-dir (dir-name)
      (cond
       ((string= dir-name "") "")
       ((string= "." (string (car (string-to-list dir-name)))) (cl-subseq ".emacs" 0 2))
       (t (string (car (string-to-list dir-name))))))

    (defun amirreza/--eshell-ring-search (name ring)
      (interactive)
      (insert (completing-read (format "%s History: " name) (ring-elements ring)))
      (eshell-send-input))

   (defun amirreza/eshell-history-search ()
     (interactive)
     (amirreza/--eshell-ring-search "Command" eshell-history-ring))


   (defun amirreza/eshell-recent-dir-search ()
     (interactive)
     (amirreza/--eshell-ring-search "Recent Dir" eshell-last-dir-ring))

    (defun amirreza/eshell-minify-path (path)
      "Minify path like what fish do for paths."
      (let* ((path-sep (split-string path "/"))
             (last-part (car (last path-sep)))
             (path-to-minify (butlast path-sep))
             (minified (mapcar 'amirreza/--minify-dir path-to-minify)))

        (concat (string-join minified "/") "/" last-part)))

    (defun amirreza/eshell-vc-info ()
      "returns a string containing information about VCS in default-directory, if vcs-backend is Git shows the current branch name"
      (let* ((vcs-backend (or (ignore-errors (vc-responsible-backend default-directory)) ""))
             (git-branch (magit-get-current-branch)))
        (cond
         ((string= vcs-backend "Git") (format "%s:%s" vcs-backend git-branch))
         (t (format "%s" vcs-backend)))))

    (defun amirreza/eshell-prompt ()
      (concat (amirreza/eshell-minify-path (eshell/pwd)) " " (amirreza/eshell-vc-info) "\n⤷ "))

    (defun amirreza/eshell-last-output ()
      (interactive)
      (copy-region-as-kill (eshell-beginning-of-output) (eshell-end-of-output)) ;; get output from eshell buffer
      (switch-to-buffer (get-buffer-create "*eshell-last-output*"))
      (erase-buffer)
      (yank))

    (setq eshell-prompt-function 'amirreza/eshell-prompt)
    (setq eshell-prompt-regexp "⤷ ")

    (defun amirreza/eshell-show-content-file-at-point ()
      "Insert the content of file at point to the end of buffer"
      (interactive)
      (let ((file (ffap-file-at-point)))
        (if file
            (progn
              (end-of-buffer)
              (insert (concat "cat " file))
              (eshell-send-input))
          (user-error "No file at point"))))

    (defun amirreza/eshell-kill-save-file-at-point ()
      "Add to kill-ring the absolute path of file at point."
      (interactive)
      (let ((file (ffap-file-at-point)))
        (if file
            (kill-new (concat (eshell/pwd) "/" file))
          (user-error "No file at point"))))

    (defun amirreza/eshell-find-file-at-point ()
      "Run `find-file' for file at point (ordinary file or dir).
          Recall that this will produce a `dired' buffer if the file is a
          directory."
      (interactive)
      (let ((file (ffap-file-at-point)))
        (if file
            (find-file file)
          (user-error "No file at point"))))


    (defun amirreza/eshell-find-sub-dirs-recur ()
      (interactive)
        (insert (amirreza/--find-sub-directories-recur "Directory: " default-directory))
        (eshell-send-input))

    :bind (:map eshell-mode-map
                ("C-c m f c" . amirreza/eshell-show-content-file-at-point)
                ("C-c m h" . amirreza/eshell-history-search)
                ("C-c m f a" . amirreza/eshell-find-file-at-point)
                ("C-c m k f" . amirreza/eshell-kill-save-file-at-point)
                ("C-c m r" . amirreza/eshell-recent-dir-search)
                ("C-c m d" . amirreza/eshell-find-sub-dirs-recur)))
#+end_src
**** VTerm
#+begin_src emacs-lisp
  (use-package vterm :straight t :commands (vterm))
#+end_src

* Development
** Completion
Code completion consists of two parts, A source/server that provides the completions and 
an engine that knows when to open prompt and show the completions. We will configure servers later
but now we need to install the engine that shows us the completion.
=Company-mode= in my opinion is the best one out there, it consists of =backends= and =frontends=
backends connect to multiple tools that provide the completions and frontends are about the GUI.
Since we are going to use LSP as the main source for the completions we just need the default 
configuration of company.
For company backends we are going to use =company-capf= which is abbrv for =company complete at point function= which is a function in Emacs that major modes
can call an get completions based on that.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :straight t
    :bind (:map company-active-map
                ("C-n" . company-select-next)
                ("C-p" . company-select-previous)
                ("C-o" . company-other-backend)
                ("<tab>" . company-complete-common-or-cycle)
                ("RET" . company-complete-selection))
    :defer 2
    :config
    (setq company-minimum-prefix-lenght 1)
    (setq company-tooltip-limit 30)
    (setq company-idle-delay 0.0)
    (setq company-echo-delay 0.1)
    (setq company-show-numbers t)
    (setq company-backends '(company-capf company-dabbrev company-files company-dabbrev-code))
    (global-company-mode t))
#+end_src
** Code Semantic Movement
Emacs has a builtin tool called Imenu which major modes hook to and feed it data about semantic blocks in the current buffer,
we can use it to jump around our code based on semantics of that language (forexample structs or functions).
#+begin_src emacs-lisp
    (use-package imenu
      :bind ("M-i" . imenu))
#+end_src
** Snippets
Every human being has limited number of keystrokes left, so let's make every one of them count.
Abbrev mode is Emacs internal that expands on defined abbrevations,
Abbrev mode is really helpful but in more complicated scenarios we need more smart tool,
so we use skeleton mode and we combine that with abbrev mode to get maximum power, we are 
going to define our skeletons in their respective languages. Snippet macro defines a new snippet,
Snippets are basically combination of abbrevs and skeletons, abbrevs are used for triggering
skeleton and skeleton does it's job of inserting text.
#+begin_src emacs-lisp
          (use-package abbrev :commands (expand-abbrev))
          (use-package skeleton :demand
            :config
            (defmacro amirreza/defsnippet (mode abbrv &rest skeleton-expansions)
              "Snippets are wrapper around skeleton and abbrevs."
              (let ((command-name (intern (format "amirreza/snippet-%s-%s" mode abbrv))))
                `(progn
                   (define-skeleton ,command-name ""
                     ,@skeleton-expansions)
                   (define-abbrev local-abbrev-table ,abbrv "" (quote ,command-name))))))
#+end_src
** Dumb Jump
Dumb jump is actually a smart way of jumping to defenitions using grep tools like
=ag= or =rg=.
#+begin_src emacs-lisp
        (use-package dumb-jump
          :straight t
          :commands
          (dumb-jump-go
           dumb-jump-back)
          :bind
          (:map prog-mode-map
                ("M->" . dumb-jump-go)
                ("M-<" . dumb-jump-back))
          :config
          (dumb-jump-mode 1))
#+end_src
** Language Server Protocol
Language Server protocol is a open source protocol developed by microsoft but now it's being
developed by community, it defines a communication protocol that a lanaguge server (let's say gopls)
can talk to various clients (let's say Emacs, Vi, VSCode) and provide several features such
as auto-complete or syntax linting.
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode 
    :straight t
    :commands (lsp lsp-deferred)
    :init
    (setq lsp-keymap-prefix "s-d")
    (setq lsp-file-watch-threshold 1000000)
    (defun amirreza/lsp? ()
      (interactive)
      --lsp-enabled)

    (defun amirreza/lsp! ()
      "Enable LSP for current buffer."
      (interactive)
      (lsp)
      (setq-local --lsp-enabled t)
      (setq-local company-backends '(company-capf)))

    (defun amirreza/disable-lsp () 
      "Disable LSP for current buffer."
      (interactive)
      (setq-local --lsp-enabled nil))

    :config
    (setq lsp-auto-guess-root t)
    :commands (lsp)
    :bind (("<f6>" . lsp-rename)
            ("C-s-." . lsp-find-references)))

    (use-package lsp-ivy :straight t 
      :commands (lsp-ivy-workspace-symbol lsp-ivy-global-workspace-symbol) 
      :bind (("s-f" . lsp-ivy-workspace-symbol)))

    (use-package dap-mode :straight t :defer t)
#+END_SRC
LSP-ui is a mode from the same author with the goal of configuring several Emacs packages to 
help ease developer experience when using LSP.
#+BEGIN_SRC emacs-lisp
  ;; (use-package lsp-ui :straight t :commands lsp-ui-mode :hook (lsp-mode . lsp-ui-mode))
#+END_SRC
** Rainbow delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters :straight t :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Syntax checking
Emacs comes with a built in syntax checker called =flymake=, but since emacs community favors =flycheck= over =flymake= we are going to setup flycheck.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :straight t
    :hook (prog-mode . flycheck-mode))
#+END_SRC
** Docs
#+begin_src emacs-lisp
  (use-package eldoc
    :config (global-eldoc-mode 1))
#+end_src
** Languages
*** Python
**** Python Mode
 Emacs itself comes with =python-mode= which is python major mode that provides emacs with 
 syntax highlighting and some other features on python, so we just need to configure it the way 
 we want. I added some custom python functions to suit my python needs like the docstring function
 that inserts a docstring in python syntax.
 #+BEGIN_SRC emacs-lisp
   (use-package python-mode
     :mode "\\.py\\'"
     :hook (python-mode-hook . amirreza/python-mode-hook)
     :config
     (defun amirreza/python-insert-docstring ()
       (interactive)
       (insert "'''\n'''")
       (previous-line))
     (defun amirreza/python-mode-hook () 
       (amirreza/lsp!))
     :bind
     (:map python-mode-map 
       ("C-s-l d" . amirreza/python-insert-docstring)))
 #+END_SRC
**** Microsoft Language Server
 #+begin_src emacs-lisp
 (use-package lsp-python-ms :straight t :after python-mode)
 #+end_src
**** Pipenv
 =Pipenv= is now the de facto tool for python programmers to manage their project deps, so it's nice
 to have a wrapper for it in Emacs.
 #+BEGIN_SRC emacs-lisp
   (use-package pipenv
	        :straight t
	        :after python-mode)
 #+END_SRC
**** Py-autopep8
 We are using LSP for all our IDE like features but right now python lanugage server does not
 provide formmatting feature for python so we need to use another package called =py-autopep8= which
 actually is just a wrapper around python package that you need to install from =pypi= called 
 no suprises =py-autopep8=. We install this package and we need this package to hook it's format 
 function to =before-save-hook= of emacs, luckily this package provides a helper function to do that.
 #+BEGIN_SRC emacs-lisp
 (use-package py-autopep8
   :straight t
   :hook python-mode
   :config
   (py-autopep8-enable-on-save))

 #+END_SRC
*** Go
**** Go-mode
 Golang by default is not supported in Emacs, but don't fear, we can fix that by simply installing
 =go-mode= which is a major mode and it provides the basic syntax highlighting that we need, we also
 need to configure this package to enable some LSP features that are necessary like formatting. For
 go to work perfectly you need to add the =GOPATH= to your =exec-path= to let emacs find go binaries
 that it needs.
 #+BEGIN_SRC emacs-lisp
   (use-package go-mode
     :straight t
     :mode ("\\.go\\'" . go-mode)
     :init
     (add-hook 'go-mode-hook 'amirreza/go-hook)
     :bind
     (:map go-mode-map
           ("C-s-l g t" . amirreza/snippet-go-tf)
           ("C-s-l g h" . amirreza/snippet-go-hh)
           ("C-s-l g f" . amirreza/snippet-go-for)
           ("C-s-l g i" . amirreza/snippet-go-if)
           ("C-s-l g p l" . amirreza/snippet-go-pl)
           ("C-s-l g p f" . amirreza/snippet-go-pf))
     :config
     (defun amirreza/go-hook ()
       (interactive)
       ;; custom snippets
       (amirreza/defsnippet "go" "fmain" "" "func main() {" \n "}")
       (amirreza/defsnippet "go" "pkgm" "Package: " "package " str \n)
       (amirreza/defsnippet "go" "pl" "" "fmt.Println(\"" _ "\")") ;; _ is the cursor position after the expansion
       (amirreza/defsnippet "go" "pf" "" "fmt.Printf(\"" _ "\")")
       (amirreza/defsnippet "go" "ifer" "" "if err != nil {" \n _ \n "}")
       (amirreza/defsnippet "go" "if" "" "if " _ "{" \n "}")
       (amirreza/defsnippet "go" "for" "" "for " _ " := range {" \n \n "}")
       (amirreza/defsnippet "go" "fn" "" "func " _ "() {" \n \n "}")
       (amirreza/defsnippet "go" "tf" "" "func " _ "(t *testing.T) {" \n \n "}")
       (amirreza/defsnippet "go" "hh" "" "func " _ "(w http.ResponseWriter, r *http.Request) {" \n \n "}")

       (define-key go-mode-map (kbd "<f5> r")
         (lambda () (interactive)
           (start-process "GoRun" "*GoRun*" "go" "run" (format "%s" buffer-file-name))))

       ;; enable LSP
       (amirreza/lsp!)
       ;; add go binaries to exec-path
       (add-to-list 'exec-path (concat (getenv "HOME") "/go/bin"))

       ;; show lambdas instead of funcs
       (setq-local prettify-symbols-alist '(("func" . 955)))
       (add-hook 'before-save-hook (lambda ()
                                     (when (amirreza/lsp?)
                                       (lsp-format-buffer)
                                       (lsp-organize-imports))) t t)))

 #+END_SRC
**** Go-add-tags
 it's always a pain to manually add struct tags for a struct specially when
 the struct has so many fields, again thanks to the emacs community we have package for that 
 to ease that task for us.
 #+BEGIN_SRC emacs-lisp
   (use-package go-add-tags :straight t :bind (:map go-mode-map ("C-s-l s" . go-add-tags)))
 #+END_SRC
**** Go-test
 =VSCode= has a great support when it comes to running go tests, it gives you the ability to 
 run a test when you are editing or viewing it but it does'nt mean that Emacs can't do that.
 #+BEGIN_SRC emacs-lisp
   (use-package gotest :straight t 
     :after go-mode
     :config
     (define-key go-mode-map (kbd "C-s-l t f") 'go-test-current-file) 
     (define-key go-mode-map (kbd "C-s-l t t") 'go-test-current-test))
  #+END_SRC
*** Scheme
 I use guile as my scheme compiler.
 #+begin_src emacs-lisp
   (use-package scheme
   :mode "\\.scm"
   :config
   (setq scheme-program-name "guile"))
 #+end_src
*** Zig
 #+begin_src emacs-lisp
   (use-package zig-mode 
     :straight t
     :mode "\\.zig\\'")
 #+end_src
*** Lisp configuration
#+begin_src emacs-lisp
  (use-package paredit :straight t
    :hook ((clojure-mode emacs-lisp-mode) . paredit-mode))
  (use-package parinfer :straight t  :hook ((clojure-mode emacs-lisp-mode) . parinfer-mode))
#+end_src
*** Emacs lisp
 Emacs lisp should be supported by default ha ? actually it has almost all support you need but 
 we can even go further.x
 #+BEGIN_SRC emacs-lisp
   (use-package elisp-mode
     :hook
     (emacs-lisp-mode-hook . amirreza/elisp-hook)
     :config
     (defun amirreza/elisp-hook ()
       (setq-local prettify-symbols-alist '(("fn" . 955)))
       (defun --amirreza/emacs-lisp-repeat (str count)
         "Create dashes with given COUNT."
         (let ((dashes ""))
           (dotimes (iterator count dashes)
             (setq dashes (concat dashes str)))))

       (defun --amirreza/emacs-lisp-wrap-text-in-spaces (text)
         (let* ((len (length text))
                (spaces-length-side (/ (- 80 len) 2))
                (spaces-side (--amirreza/emacs-lisp-repeat " " spaces-length-side)))
           (format "%s%s%s" spaces-side text spaces-side)))

       (defun amirreza/emacs-lisp-insert-comment-line (text)
         "Insert a comment line with given TEXT."
         (interactive "sComment: ")
         (let* ((text-wrapped (--amirreza/emacs-lisp-wrap-text-in-spaces text))
                (dashes (--amirreza/emacs-lisp-repeat "=" 80))))
         (insert (format "\n;;%s\n;;%s\n;;%s" dashes text-wrapped dashes))))
     :bind
     (:map emacs-lisp-mode-map
           ("C-s-l d" . 'amirreza/emacs-lisp-insert-comment-line)))
 #+END_SRC
*** Clojure
**** Clojure Mode
     #+BEGIN_SRC emacs-lisp
       (use-package clojure-mode :straight t
         :mode "\\.cljs?\\'"
         :config
         (setq-local prettify-symbols-alist '(("fn" . 955) ; λ
                                               ("->" . 8594))))
     #+END_SRC
**** Cider
 #+BEGIN_SRC emacs-lisp
   (use-package cider 
     :straight t
     :commands (cider cider-jack-in))
 #+END_SRC
*** Common Lisp
**** Common-lisp mode
 #+BEGIN_SRC emacs-lisp
 (use-package lisp-mode :mode "\\.cl\\'")
 #+END_SRC
**** Common Lisp Integrated Environment
 #+BEGIN_SRC emacs-lisp
 (use-package sly :straight t :mode "\\.cl\\'")
 #+END_SRC
*** Haskell
**** Haskell mode
 #+BEGIN_SRC emacs-lisp
 (use-package haskell-mode :straight t :mode "\\.hs\\'")
 #+END_SRC
**** Haskell IDE engine
 #+BEGIN_SRC emacs-lisp
 (use-package lsp-haskell :straight t :hook haskell-mode)
 #+END_SRC
*** HTML/CSS
 #+BEGIN_SRC emacs-lisp
   (use-package web-mode :straight t :mode ("\\.html\\'" "\\.css\\'") :config (web-mode-toggle-current-element-highlight))
 #+END_SRC
*** PHP
**** PHP mode
 #+BEGIN_SRC emacs-lisp
   (use-package php-mode :straight t 
     :mode "\\.php\\'"
     :hook (php-mode . amirreza/php-mode-hook)
     :config (defun amirreza/php-mode-hook ()
               (amirreza/lsp!)))
 #+END_SRC
**** PHP Runtime Integration
 #+BEGIN_SRC emacs-lisp
 (use-package php-runtime :straight t :after php-mode)
 #+END_SRC
**** Composer Integration
 #+BEGIN_SRC emacs-lisp
   (use-package composer :straight t :after php-mode)
 #+END_SRC
**** PHPUnit
 #+BEGIN_SRC emacs-lisp
   (use-package phpunit :straight t
     :after php-mode
     :config 
     (define-key php-mode-map (kbd "C-s-l t t") 'phpunit-current-test)
     (define-key php-mode-map (kbd "C-s-l t c")  'phpunit-current-class)
     (define-key php-mode-map (kbd "C-s-l t p")  'phpunit-current-project))
 #+END_SRC
*** Rust
**** Rust mode
 #+BEGIN_SRC emacs-lisp
 (use-package rust-mode :straight t :mode "\\.rs\\'")
 #+END_SRC
*** Protobuf
#+begin_src emacs-lisp
(use-package protobuf-mode :load-path "/home/amirreza/.emacs.d/site-lisp" :mode "\\.proto\\'")
#+end_src
* VCS
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :straight t
    :commands (magit-status magit-get-current-branch)
    :bind
    (("C-x g" . 'magit-status)
     ("C-s-v s" . 'magit-status)))

  (use-package diff-hl
    :straight t
    :config (global-diff-hl-mode 1))

  (use-package gitconfig-mode
    :straight t
    :mode "/\\.gitconfig\\'")

  (use-package gitignore-mode
    :straight t
    :mode "/\\.gitignore\\'")

  (use-package gitattributes-mode
    :straight t
    :mode "/\\.gitattributes\\'")

  (use-package git-messenger
    :straight t
    :commands
    (git-messenger:popup-message)
    :bind
    (("C-c v b" . git-messenger:popup-message)
     ("C-s-v b" . git-messenger:popup-message))
  
    :config
    (setq git-messenger:show-detail t)
    (setq git-messenger:use-magit-popup t))
#+END_SRC
** Smerge
#+begin_src emacs-lisp
  (use-package smerge-mode
    :bind (:map smerge-mode-map
                ("C-c m h" . amirreza-smerge-hydra/pretty-body))
    :config
    (pretty-hydra-define amirreza-smerge-hydra (:hint nil :exit t)
                         ("Merge Action: "
                          (("n" smerge-next)
                          ("p" smerge-prev)
                          ("u" smerge-keep-upper)
                          ("b" smerge-keep-base)
                          ("l" smerge-keep-lower)
                          ("a" smerge-keep-all)
                          ("q" nil "Cancel")))))
#+end_src
* Dired
#+begin_src emacs-lisp
  (use-package dired
    :commands (dired dired-jump)
    :bind (("C-x C-j" . dired-jump))
    :config
    (add-hook 'dired-mode-hook (lambda () 
                                 (dired-hide-details-mode 1))))

  (use-package dired-sidebar :straight t
    :bind
    (("<f8>" . dired-sidebar-toggle-sidebar)))

  (use-package dired-subtree
    :straight t
    :bind (:map dired-mode-map
                ("<tab>" . dired-subtree-toggle)))

  (use-package peep-dired
    :straight t
    :after dired
    :config
    (setq peep-dired-cleanup-on-disable t)
    (setq peep-dired-enable-on-directories nil)
    (setq peep-dired-ignored-extensions
          '("mkv" "webm" "mp4" "mp3" "ogg" "iso"))
    :bind (:map dired-mode-map
                ("P" . peep-dired)))
#+end_src
* IRC
#+begin_src emacs-lisp
  (use-package erc 
    :commands erc
    :config
    (setq erc-nick "amirrezaask")
    (setq erc-autojoin-channels-alist
          '(("freenode.net" "#emacs" "#5hit"))))
#+end_src
* Process management
#+begin_src emacs-lisp
  (use-package proced
    :bind (("C-c o p" . proced)
           ("<f10>" . proced))
    :commands proced)
#+end_src
* Music
** Rhythmbox
#+begin_src emacs-lisp
  (use-package rhythmbox
    :bind (("C-s-m l" . Rhythmbox)
           ("C-s-m p" . Rhythmbox/playpause-current-song)
           ("C-s-m n" . Rhythmbox/current-song-name))
    :straight (:host github :repo "amirrezaask/Rhythmbox.el"))
#+end_src
* Video
#+begin_src emacs-lisp
  (defun amirreza/start-vlc (filename)
    (start-process (format "*VLC: %s*" filename) "*VLC*" "vlc" filename))

  (defvar amirreza/video-location "~/Videos")

  (defun amirreza/video-list ()
    (interactive)
    (amirreza/start-vlc (expand-file-name (completing-read "Video: " (directory-files-recursively amirreza/video-location ".*")))))
#+end_src
* Configuration files
 #+begin_src emacs-lisp
   (use-package crontab-mode :defer t :straight t)
   (use-package apache-mode :straight t
     :mode ("\\.htaccess\\'" "httpd\\.conf\\'" "srm\\.conf\\'" "access\\.conf\\'"))
   (use-package systemd :straight t
     :mode ("\\.service\\'" "\\.timer\\'"))
   (use-package nginx-mode :straight 
     :mode ("/etc/nginx/conf.d/.*" "/etc/nginx/.*\\.conf\\'"))
 #+end_src
* Tramp
#+begin_src emacs-lisp
    (use-package tramp
          :commands (tramp)
          :config
          (setq tramp-default-method "ssh"))
#+end_src
* Docker
#+BEGIN_SRC emacs-lisp
  (use-package docker-compose-mode
    :straight t
    :mode "docker-compose\\.yml")

  (use-package docker :straight t 
    :bind
    ("C-s-d" . docker))
  (use-package dockerfile-mode :straight t :mode "\\Dockerfile\\'")
#+END_SRC
* Kubernetes
#+begin_src emacs-lisp
(use-package kubel :straight t :commands (kubel) :bind (("C-s-k" . kubel)))
#+end_src
* Benchmark startup time
#+begin_src emacs-lisp
(defvar amirreza/startup-elapsed (- (float-time) amirreza/emacs-init-timestamp))
#+end_src
