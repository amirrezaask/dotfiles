#+TITLE: AmirrezaAsk Emacs configuration
#+AUTHOR: amirrezaask
* Table Of contents                                                     :TOC@4:
- [[#introduction][Introduction]]
- [[#what-is-emacs-][What is Emacs ?]]
  - [[#editor--ide--mail-client--window-manager--terminal-emulator--lisp-interpreter--all-of-them--none-][Editor ? IDE ? Mail client ? Window manager ? Terminal emulator ? Lisp interpreter ? all of them ? none ?]]
- [[#ascend-from-darkness][Ascend from darkness]]
  - [[#installing-emacs][Installing Emacs]]
  - [[#let-your-feet-get-wet][Let your feet get wet]]
    - [[#opening-a-file][Opening a file]]
    - [[#motions][Motions]]
    - [[#emacs-is-self-documenting][Emacs is self documenting]]
    - [[#elisp][Elisp]]
      - [[#hello-world][Hello World]]
      - [[#loading-evaluating-file][Loading (Evaluating) file]]
  - [[#start-your-configuration][Start Your configuration]]
  - [[#introducing-emacs-27][Introducing Emacs 27]]
- [[#personal-information][Personal information]]
- [[#emacs-internals-optimizations][Emacs internals optimizations]]
  - [[#gc][GC]]
  - [[#file-name-handler-alist][file-name-handler-alist]]
- [[#debug-when-necessary][Debug When necessary]]
- [[#setup-package-manager][Setup package manager]]
  - [[#packageel-setup][Package.el setup]]
    - [[#use-package][Use-package]]
  - [[#straightel][Straight.el]]
- [[#evil-always-wins][Evil always wins]]
- [[#exwm-emacs-x-window-manager][Exwm (Emacs X window manager)]]
- [[#ui][UI]]
  - [[#themes][Themes]]
      - [[#performance-tip][Performance Tip]]
  - [[#font][Font]]
  - [[#icons][Icons]]
  - [[#modeline][Modeline]]
  - [[#dashboard][Dashboard]]
- [[#emacs-modes-introduction][Emacs Modes Introduction]]
- [[#sync-emacs-exec-path-with-os][Sync Emacs exec path with OS]]
- [[#windows][Windows]]
      - [[#window-rules][Window rules]]
      - [[#eyebrowse][Eyebrowse]]
      - [[#winner-restore-window-layout][Winner (Restore Window layout)]]
      - [[#ace-window-better-window-management][Ace Window (Better Window Management)]]
- [[#file-manager][File Manager]]
- [[#mail--news-reader][Mail & News reader]]
- [[#irc][IRC]]
- [[#process-management][Process management]]
- [[#org-mode][Org Mode]]
- [[#editor][Editor]]
    - [[#defaults][Defaults]]
    - [[#set-a-new-custom-file][Set a new custom file]]
    - [[#delete-selection-when-inserting-into-it][Delete selection when inserting into it]]
    - [[#show-keychords-more-fast][Show keychords more fast]]
    - [[#backup-files][Backup files]]
    - [[#dont-type-yes-every-time][don't type yes every time]]
    - [[#edit-configuration][Edit configuration]]
    - [[#large-files-handling][Large files handling]]
    - [[#beacon][Beacon]]
    - [[#some-general-keybindings][Some general keybindings]]
    - [[#highlight-matching-parens][Highlight matching parens]]
    - [[#reduce-clutter-in-emacs-frame][Reduce clutter in emacs frame]]
    - [[#some-informative-numbers][Some informative numbers]]
    - [[#some-cursor-tweaks][Some cursor tweaks]]
    - [[#interactive-editiedit][Interactive Edit(IEdit)]]
    - [[#interactive-buffer-management][Interactive Buffer Management]]
    - [[#multiple-cursors][Multiple Cursors]]
    - [[#jump-to-defenition][Jump to defenition]]
    - [[#highlight-todos][Highlight TODOs]]
    - [[#expand-region][Expand Region]]
    - [[#sudo-edit][Sudo Edit]]
    - [[#highlight-indents][Highlight Indents]]
    - [[#improve-scrolling][Improve Scrolling]]
    - [[#which-key][Which key]]
    - [[#dumb-jump][Dumb Jump]]
    - [[#searching][Searching]]
    - [[#atomic-typing][Atomic Typing]]
    - [[#rainbow-delimiters][Rainbow delimiters]]
    - [[#rainbow-blocks][Rainbow Blocks]]
- [[#selection-candidates][Selection Candidates]]
    - [[#icomplete][Icomplete]]
    - [[#ido][IDO]]
    - [[#ivy][Ivy]]
    - [[#helm][Helm]]
- [[#completion][Completion]]
- [[#integrated-development-environment][Integrated Development Environment]]
    - [[#terminal-emulator][Terminal Emulator]]
      - [[#vterm][VTerm]]
    - [[#language-server-protocol][Language Server Protocol]]
    - [[#git-integration][Git integration]]
    - [[#syntax-checking][Syntax checking]]
    - [[#debugger-support][Debugger Support]]
    - [[#docs][Docs]]
    - [[#project-detection][Project Detection]]
    - [[#music][Music]]
      - [[#using-rhythmboxel][Using Rhythmbox.el]]
      - [[#using-counsel][Using counsel]]
- [[#programming-languages][Programming Languages]]
  - [[#python][Python]]
    - [[#python-mode][Python Mode]]
    - [[#microsoft-language-server][Microsoft Language Server]]
    - [[#pipenv][Pipenv]]
    - [[#py-autopep8][Py-autopep8]]
  - [[#go][Go]]
    - [[#go-mode][Go-mode]]
    - [[#go-add-tags][Go-add-tags]]
    - [[#go-test][Go-test]]
  - [[#scheme][Scheme]]
  - [[#gs-go-scheme][GS (Go Scheme)]]
  - [[#elisp-1][Elisp]]
  - [[#clojure][Clojure]]
    - [[#clojure-mode][Clojure Mode]]
    - [[#cider][Cider]]
  - [[#common-lisp][Common Lisp]]
    - [[#common-lisp-mode][Common-lisp mode]]
    - [[#common-lisp-integrated-environment][Common Lisp Integrated Environment]]
  - [[#haskell][Haskell]]
    - [[#haskell-mode][Haskell mode]]
    - [[#haskell-ide-engine][Haskell IDE engine]]
  - [[#htmlcss][HTML/CSS]]
  - [[#php][PHP]]
    - [[#php-mode][PHP mode]]
    - [[#php-runtime-integration][PHP Runtime Integration]]
    - [[#composer-integration][Composer Integration]]
    - [[#phpunit][PHPUnit]]
  - [[#rust][Rust]]
    - [[#rust-mode][Rust mode]]
- [[#devops][Devops]]
    - [[#some-syntax-highlights][Some syntax highlights]]
    - [[#tramp][TRAMP]]
    - [[#docker][Docker]]
    - [[#kubernetes][Kubernetes]]
    - [[#redis][Redis]]
- [[#games][Games]]
  - [[#pacman][Pacman]]

* Introduction
=Emacs= is one of the oldest softwares that has active development and community after 40 years passed from the initial release, but why is
that ? Why when there battries included, easy to use, full-featured solutions like =VSCode=, =Jetbrains IDEA= (I mean whole Jetbrains family),
 =Atom=, =Sublime=, etc... people still use =Emacs=, What is the reason that keeps these programs alive? Is it just some people want to look
cool ? Or is there really something ? We are going to take a journey into the deepest parts of EMACS and find the answer.
* What is Emacs ?
** Editor ? IDE ? Mail client ? Window manager ? Terminal emulator ? Lisp interpreter ? all of them ? none ?
At the 70s at =MIT= AI lab computers were running an editor called =TECO= which was modal editor, as the time passed
problems of =TECO= started to create the need for a new editor paradigm, and one new implemention
 catched on very well, guy named =Fred Wright= created an editor called =E=, which was much more similar to modern
editors we know, and Stallman added same functionality to =TECO= program.
At the year 1984 =Stallman= Sta[INC]
So Emacs is an editor implemented in Emacs-lisp which is an Lisp dialect implemented in C, so basically Emacs is
a Lisp interpreter which happens to have a editor inside as well. All editor functionality is written in pure emacs-lisp
or they have the API for emacs-lisp so you can change them, you can actually change almost anything in Emacs since
every thing is a function or a variable defined in Emacs-lisp and evaluated using Emacs internal lisp evaluator and 
Emacs-lisp like many lisps has no function scoping, in simpler terms there is no private functions or variables so 
you can change the most core parts of EMACS easily with just redefining them.
* Ascend from darkness
** Installing Emacs
Installing Emacs is easy, if you are on a =GNU/Linux= distro you should be able to get it from the package manager and
in =macOS= it's available in =homebrew= and you can download windows version from gnu/emacs website.
** Let your feet get wet
*** Opening a file
Open up Emacs, what you see is a tedious white screen with an ugly Emacs logo and some links for tutorials on Emacs
(these links are actually useful take a look at them). First let's get on the same page, from this point to the
end of the document =C= in keybindings refers to control key and =M= refers to Meta(Alt) key, =S= is shift and =s= 
is super key. Open a file by pressing =<C-x C-f>=, you get a prompt to enter a file name, enter some random file name
an hit enter, file is opened and you can see the content. Let's create a table to remember the keychords we are using

| Keychord | functionality |
| C-x C-f  | opens a file  |

*** Motions
Let's move around, ofcourse you can use the mouse and click around or the arrow keys but there are more efficient
ways doing this, Just press =<C-f>= you see your cursor moves forward by a character, now press =<C-b>= and your 
cursor moves backward by a character so lets update our table. Remember there are so much more in motions these two
were just examples.

| Keychord | functionality                 |
| C-f      | moves forward by a character  |
| C-b      | moves backward by a character |

*** Emacs is self documenting
Do you remember that I told you in Emacs every thing is just an Elisp(Emacs-lisp) function, let's discuss that.
Let me introduce you to the Emacs self documenting feature, press =<C-h k>=, you should be prompted then enter
=<C-x C-f>= a new window(we'll discuss this concept later), you see a document that tolds you what this keychord
is bound to and the documentation of that function, in this case you should see that =<C-x C-f>= is bound to 
=find-file= command and you have the option to see the actual source code of that function. =<C-h>= is the prefix 
for all Emacs help commands and these keys themselves runs elisp functions you can actually do the =<C-h k>=
on itself and see the function behind it so let's update our table and from now on we write the actual function name 
in our table.

| Keychord | function          |
|----------+-------------------|
| C-h k    | describe-key      |
| C-h f    | describe-function |
| C-h v    | describe-variable |

*** Elisp
I'm not going to do a complete tutorial on Elisp just gonna tell you how you can stay alive in Emacs.
**** Hello World
Elisp or Emacs-Lisp is the language that almost all Emacs functions are written in, so let's tip our toes in it as 
well.
Open up a new file ( you already know how to do that ) name that anything but with the extension of =.el=.
at the first line write the following 
#+BEGIN_SRC 
(message "Hello World")
#+END_SRC
and then move your cursor to the end of the line using =<C-e>= and then press =<C-x C-e>=, now look at the =minibuffer=
you see the ="Hello World"= in there. Don't forget to =describe-key= the two keychords that you just used.
**** Loading (Evaluating) file
:PROPERTIES:
  :header-args: :tangle no
  :END:
You can evaluate eLisp expressions like you now know but you also can load a whole elisp file using =load-file= function
#+BEGIN_SRC 
(load-file "file.el")
#+END_SRC
** Start Your configuration
 Emacs configuration is nothing other than a simple elisp file that emacs loads at the startup we can specify that
 using =-l= flag to load specific file. so let's do that. Open an elisp file and name that =config.el=, and just put
 a simple hello world message in it, now go to terminal and enter =emacs -l config.el= when this instance of emacs starts
 up =switch-to-buffer= (this is a function you can describe-function it and find the keybindings little exercise)
 to the buffer called =*Messages*= and you should see your message in that buffer somewhere.
 Now you can write any elisp code in your config.el file and emacs always evaluates them as long as you pass the
 -l flag, but the conventional way of doing emacs configuration is using =~/.emacs.d/init.el= file which emacs 
 automatically loads in the startup, it's kind of the default file for this purpose.
** Introducing Emacs 27
Emacs 27 has a lot to offer, a new json parser that is implemented natively (C code) so it should speed
up the JSON based operations like LSP a lot, another thing about Emacs 27 is =early-init.el= file that gets
loaded before init.el and before GUI and package manager starts so it can help us configure Emacs even further.
* Personal information
#+begin_src emacs-lisp
    (setq user-full-name "AmirrezaAskarpour"
          user-mail-address "raskarpour@gmail.com")
#+end_src
* Emacs internals optimizations
:PROPERTIES:
  :header-args: :tangle no
  :END:
I moved all of the code of this part to =early-init.el=.
** GC
Emacs is a really old software, many of the default values in Emacs aren't actually suited for today's
modern computers. Emacs has a built-in Garbage collector that does garbage collection every time Emacs lisp
VM reaches a threshold of memory usage, and this garbage collector sweeps are sometimes annoying, but remember 
garbage collector threshold is a tricky setting, if you set it to low you will start experiencing a lot of GC sweeps that slow you down
and if you set it very high GC sweeps take forever to finish. Default Emacs =gc-cons-threshold= is set to =800000=
which is not really enough specially for Emacs startup since it needs to scan through all your installed packages
so we are going to increase it during startup time and then after Emacs initialization we can decrease it again.
#+begin_src emacs-lisp
  (message "$$$$$$$$$$$$$$$$ should be disabled")
  (setq gc-cons-threshold (* 1024 1024 100)) ;; 100MB for Emacs initialization process
  (add-hook 'after-init-hook (lambda ()
                               (setq gc-cons-threshold (* 1024 1024 20)))) ;; reseting the gc cons to 20MB
#+end_src
** file-name-handler-alist
Emacs has a global variable called =file-name-handler-alist=, it stores handlers for various file extensions, before =use-package= era we used to
add new file extensions to this variable to load their respective handler, On every file open, Emacs looks and scans through this variable to see if it
can find a match for given file, but during the startup process we are going to only evaluate stuff so we don't need file-handlers, as result we are going 
to set this file's value to a nil value during startup and restore it's original value after emacs initialization.
#+begin_src emacs-lisp
  (defvar file-name-handler-alist-bak file-name-handler-alist "file name handler backup.")
  (setq file-name-handler-alist nil)
  (add-hook 'after-init-hook (lambda () (setq file-name-handler-alist file-name-handler-alist-bak)))
#+end_src
* Debug When necessary
#+begin_src emacs-lisp
;; (setq debug-on-error)
#+end_src
* Setup package manager
Now that we know how to move around, open files, and do some elisp magic in emacs it's time to start configuring 
emacs for our own needs. Before we start, we need the final ingredient for our configuration and that's how 
to install 3rd party packages for emacs, basically elisp codes written by other people.
** Package.el setup
:PROPERTIES:
  :header-args: :tangle no
  :END:
Emacs is bundled with package.el, we can use that out of the box, we only need to =require= it, require is similar
to =load-file= with some diferences like it don't need full path when code is in you =load-path= (load-path
is a variable you can describe-variable it) and it loads each file only once so if you require a file multiple 
times it only loads once.
#+BEGIN_SRC emacs-lisp
(require 'package)
#+END_SRC
package.el reads all installed packages even if they are not referenced by your init we need to stop it 
from doing so.
#+BEGIN_SRC emacs-lisp
(setq package-enable-at-startup nil)
#+END_SRC
As I told you elpa is a lot like linux repos, and like them you can add external repos to it as well, =Melpa=
is the biggest and most complete package repo in the planet of Emacs and we are adding it to our repos.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/"))
  (package-initialize)
 #+END_SRC
Like all linux repos we need to refresh the index of the package manager but we don't need Emacs does that 
every time that we start emacs, we need to that only when package-archive-contents is nil so we use =when=
macro of elisp (like always you can describe-function it).
#+BEGIN_SRC emacs-lisp
   (when (null package-archive-contents)
     (package-refresh-contents))
#+END_SRC
*** Use-package
  Now the world is our oyster, you can actually browse the [[https://github.com/emacs-tw/awesome-emacs]] and install
  any package you seem fit using 
  But as the number of installed packages gets bigger emacs starts slow when starting up and managing and organizing
  your init.el file getting harder and harder to the point that they call it =Emacs bankrupty=.
  So to avoid this problems Emacs maintainer =John wiegly= created a tool called =use-package= that helps you oraganize
  your init.el file and even lazy-load packages, It's an awesome tool so let's install it.
  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
      (package-install 'use-package))
    (require 'use-package)
  #+END_SRC
  Feel free to read the [[https://github.com/jwiegley/use-package][use-package docs]], it's amazingly useful.
** Straight.el
=straight.el= is the next generation of Emacs package managers that just use git repos as the way
of installing packages, upsides of using =straight.el= instead of =package.el= are
+ You can install packages that are not available on MELPA (icomplete-vertical forexample)
+ If you are willing to contribute to a package it's as simple as just =git checkout=
+ straight loads just the packages you installed and mention in your init file so packages that are installed 
but no longer used are not included in loading/scanning procedure.
#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  (straight-use-package 'use-package)
#+end_src
* Evil always wins
"Emacs is a great operating system lacking only a decent editor", I always find this quote to be
true Emacs as software package/framework is amazing I mean I think people that are working on various 
types of frameworks out there should really start studying Emacs as an inspiration of how you can write 
a customizable yet robust software that would last for 40 years and yet new generations start using it yet
Emacs editor actually doesn't follow Emacs extensibility and composibility philosophy a lot, Emacs editor is based
on specific targeted functions, you have =delete-word=, it just deletes a word you can not tell it to delete two
words (yes you can do C-2 M-d) but it's not that user-friendly actually, so without further ado let's decend into
darkness. 
#+begin_src emacs-lisp
  (use-package evil
    :disabled t
    :straight t
    :init
    (setq evil-want-keybinding nil)
    :custom
    (evil-move-beyond-eol t)
    :config
    (define-key evil-motion-state-map (kbd "TAB") nil)
    (evil-ex-define-cmd "q" 'kill-this-buffer)
    (evil-mode +1))


  (use-package evil-collection 
    :disabled t
    :straight t 
    :config 
    (evil-collection-init))

  (use-package evil-magit 

  :disabled t
    :straight t)

  (use-package evil-surround 
  :disabled t
    :straight t)

  (use-package evil-commentary 
  :disabled t
    :config
    (evil-commentary-mode 1)
    :straight t)

  (use-package general
    :straight t
    :config
    (defvar amirreza/leader-key "SPC")
    (general-create-definer space-leader-lord :prefix "SPC" :states 'normal :keymaps 'override)
    (general-create-definer space-leader :prefix "SPC" :states 'normal)
    (space-leader-lord
      "s b" 'switch-to-buffer
      "b l" 'switch-to-buffer
      "k b" 'kill-buffer
      amirreza/leader-key 'find-file
      "e e" 'execute-extended-command
      "m w" 'delete-other-windows
      "d w" 'delete-window
      "s r" 'split-window-right
      "s b" 'split-window-below
      "e s" 'eval-last-sexp
      "f f" 'find-file
      "d f" 'describe-function
      "d v" 'describe-variable
      "d k" 'describe-key
      "b n" 'next-buffer
      "b p" 'previous-buffer)
    (space-leader 
      "C-k" (lambda () (interactive) (previous-line 5))
      "C-j"(lambda () (interactive) (next-line 5))))

#+end_src
* Exwm (Emacs X window manager)
#+begin_src emacs-lisp
  (use-package exwm 
    :disabled t
    :straight t
    :config 
    (require 'exwm-config)

    (exwm-config-default) ;; some basic default keybindings

    (setq exwm-workspace-number 4) ;; initial workspaces

    (setq exwm-input-simulation-keys
          '(([?\C-b] . [left])
            ([?\C-f] . [right])
            ([?\C-p] . [up])
            ([?\C-n] . [down])
            ([?\C-a] . [home])
            ([?\C-e] . [end])
            ([?\M-v] . [prior])
            ([?\C-v] . [next])
            ([?\C-d] . [delete])
            ([?\C-k] . [S-end delete])))

    ;;multiple screen support
    (require 'exwm-randr)
    (defvar amirreza/laptop-screen-name "e-DP1")
    (defvar amirreza/second-screen-name "HDMI-2")
    (setq exwm-randr-workspace-output-plist '(0 "e-DP1" 1 "HDMI-2"))
    (defun amirreza/exwm-multi-screen ()
      (start-process-shell-command
       "xrandr" nil "xrandr --output " amirreza/laptop-screen-name " --below " amirreza/second-screen-name " --auto"))
    ;; (add-hook 'exwm-randr-screen-change-hook 'exwm-change-screen-hook)
    (exwm-randr-enable)

    )

#+end_src
* UI
** Themes
 Now that we have use-package we can start installing thems, packages, etc. Let's start by installing some thems.
 for some time now I am using modus themes by the amazing =Protesilaos Stavrou= (btw check his youtube channel) which are simple but elegant themes
 but if you want a more modern look like =VSCode= or =Atom= you can use =doom-themes= as well.
 ([[https://github.com/hlissner/emacs-doom-themes/tree/screenshots][Doom Themes Screenshots]])
 #+BEGIN_SRC emacs-lisp
   (use-package modus-operandi-theme :straight t :defer t)
   (use-package modus-vivendi-theme :straight t :defer t)
   (use-package spacemacs-theme :straight t :defer t)
   (use-package doom-themes :straight t :defer t)
   (use-package badwolf-theme :straight t :defer t)
 #+END_SRC
 You probably notice the =:defer= part in use-package, with =:defer= keyword (:something is called a keyword in elisp)
 use-package knows that we don't need this package to be loaded in startup, since we actually don't need all of our themes
 to be loaded at startup. Another keyword that you see is =:straight= that is telling use-package to make certain
 that this package is installed, and if it's not install it from elpa repo.
 Now let's set a theme
 #+BEGIN_SRC emacs-lisp
         (use-package emacs 
           :custom 
           (ring-bell-function t)
           (visible-bell t))

         (use-package custom
           :demand
           :bind (("<f12>" . amirreza/toggle-color-mode))
           :config
           (defvar amirreza/current-mode 'dark "Current color of Emacs.")
           (defvar amirreza/dark-theme 'modus-vivendi)
           (defvar amirreza/light-theme 'modus-operandi)
  
           (defmacro amirreza/--load-theme (&rest theme-opts)
             `(progn (mapc #'disable-theme custom-enabled-themes)
                     (load-theme ,@theme-opts)))

           (defun amirreza/load-theme (theme)
             (interactive "sEnter Theme: ")
             (amirreza/--load-theme (intern theme) t))
           (defun amirreza/apply-color (mode)
             "Apply current color mode to Emacs."
             (if (eq amirreza/current-mode 'dark)
                 (amirreza/--load-theme amirreza/dark-theme t)
               (amirreza/--load-theme  amirreza/light-theme t)))

           (defun amirreza/toggle-color-mode ()
             "Toggle current mode to the opposite"
             (interactive)
             (if (eq amirreza/current-mode 'dark)
                 (setq amirreza/current-mode 'light)
               (setq amirreza/current-mode 'dark))
             (amirreza/apply-color amirreza/current-mode))

           (amirreza/apply-color amirreza/current-mode))
 #+END_SRC
**** Performance Tip 
About 95% of packages we use don't need to be loaded at startup and =:defer= is only one of the multiple
ways of lazy-loading in use-package we will see others later on.
** Font
 To use specific font in Emacs you just need to call a function, that's easy ha ??
 #+BEGIN_SRC emacs-lisp
   (defvar amirreza/font "Fira Code-10")
   (set-face-attribute 'default t :font amirreza/font)
   (set-frame-font amirreza/font nil t)
   (global-prettify-symbols-mode 1)
 #+END_SRC
 If you evaluate code above you see the font changes.
 Now let's write some elisp, let's say that we want to have a function that we can call and change 
 our font interactively, let's write it.
 #+BEGIN_SRC emacs-lisp
   (defun hitchhiker/change-font (font size)
     (interactive "sFont: \nnSize: ")
     (set-face-attribute 'default t :font (format "%s-%d" font size))
     (set-frame-font (format "%s-%d" font size) nil t))
 #+END_SRC
 I'm not gonna discuss this function line by line, I'm only going to discuss calling it for now,
 for calling this function we have two ways, calling it from the code, or calling it interactively
 but how ? Emacs has a default keychord called M-x (execute-extended-command) that calls a interactive
 function interactively, many packages has these kind of functions for example load-theme that we used
 before is interactive as well, if we call it we will prompted to enter the font first and then the size
 and volla :).

** Icons
Emacs by default has no icons anywhere, but if you like icons forexample in the file browser
you need to install a package for that. For icons we are going to use =all-the-icons= package which
is a gourges icon package for emacs.
#+BEGIN_SRC emacs-lisp :eval no
  (use-package all-the-icons
    :disabled t
    :straight t
    :commands (all-the-icons-octicon
           all-the-icons-faicon
           all-the-icons-fileicon
           all-the-icons-wicon
           all-the-icons-material
           all-the-icons-alltheicon))

  (use-package all-the-icons-dired
    :disabled t
    :straight t
    :init
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC
=:commands= in use-package defers the loading of the package until on of listed commands (interactive functions)
is called, basically first buffer that wants to use that it will get loaded. =:init= means when emacs started 
no matter what are the other options evaluate the forms after =:init=.
** Modeline
*** Spaceline
Modeline from Spacemacs, it's basically boosted powerline
#+begin_src emacs-lisp
  (use-package spaceline :straight t
    :disabled t
    :config
    (require 'spaceline-config)
    (spaceline-spacemacs-theme))
#+end_src
*** Doom-modeline
#+begin_src emacs-lisp
  (use-package doom-modeline :straight t
    :disabled t
    :custom
    (doom-modeline-height 35)
    :config
    (doom-modeline-mode 1))
#+end_src
*** Telephone line
#+begin_src emacs-lisp
  (use-package telephone-line :straight t
    :disabled t
    :config
    (telephone-line-mode +1))
#+end_src
*** My Custom modeline
**** Time/Date
#+begin_src emacs-lisp
  (use-package time
    :config
    (setq display-time-format "%H:%M  %Y-%m-%d")
    (setq display-time-interval 60)
    (setq display-time-mail-directory nil)
    (setq display-time-default-load-average nil)
    (display-time-mode))
#+end_src
**** Battery
#+begin_src emacs-lisp
  (use-package battery
    :config
    (setq battery-mode-line-format " [%b%p%%]")
    (setq battery-mode-line-limit 99)
    (setq battery-update-interval 180)
    (setq battery-load-low 20)
    (setq battery-load-critical 10)
    (display-battery-mode +1))
#+end_src
**** Actual mode line format
#+begin_src emacs-lisp
  (use-package emacs 
    :config
    (setq-default mode-line-format (list
                                    mode-line-front-space
                                    mode-line-misc-info ;; eyebrowse workspace number
                                    "   "
                                    mode-line-modified
                                    "   " 
                                    "%m"
                                    "   " 
                                    "%b"
                                    "   "
                                    mode-line-position
                                    "   "
                                    '(:eval vc-mode)
                                    mode-line-end-spaces
                                    )))
#+end_src
*** Nyan Cat
#+begin_src emacs-lisp
  (use-package nyan-mode :straight t :disabled t :config (nyan-mode 1))
#+end_src
** Dashboard
#+begin_src emacs-lisp
  (use-package dashboard
    :straight t
    :custom
    (dashboard-banner-logo-title "Free as in freedom")
    (dashboard-startup-banner 2)
    (dashboard-center-content t)
    (dashboard-items '((projects . 5)
                       (recents  . 5)))

    :config
    (setq dashboard-set-navigator t)
    (dashboard-setup-startup-hook))
#+end_src
* Emacs Modes Introduction
First let's talk about modes, Modes are the conventional way to add functionality to Emacs.
There are two groups of modes, Major modes and minor modes, Major modes are single modes that 
get's loaded with a specific file extension, and they provide basic syntax highlighting.
but minor modes are modes that can be loaded together for a buffer, so each buffer has a single 
major mode, and multiple minor modes that added different abilities to emacs for a buffer.
Forexample line numbers is a minor mode that is enabled globally for all buffers so all buffers
show line numbers.
Now that we have cool looks, 
* Sync Emacs exec path with OS
#+begin_src emacs-lisp
(use-package exec-path-from-shell :straight t :config (exec-path-from-shell-initialize))
#+end_src
* Windows
Emacs by default has no notion of tabs (like the other IDEs) but it has the more powerful
notion of windows and buffers, you already know about buffers, but windows are a way of displaying 
buffers side by side in the screen, look at windows like tmux panes (if I'm correct) or vim splits.
**** Window rules
Emacs windows can be configured in the matter of where their gonna open.
#+BEGIN_SRC emacs-lisp
    (setq display-buffer-alist
          '(("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Messages\\)\\*"
               (display-buffer-in-side-window)
               (window-width . 0.40)
               (side . right)
               (slot . 0))
            ("^vterm"
              (display-buffer-in-side-window)
              (window-height . 0.25)
              (side . bottom)
              (slot . 1)
              )
            ("\\*rg"
              (display-buffer-in-side-window)
              (window-height . 0.20)
              (window-width . 0.20)
              (side . top)
              (slot . 1))))
#+END_SRC
**** Eyebrowse
=Eyebrowse= gives you =i3= like experience in Emacs, let's you have multiple workspaces and switch between them.
#+BEGIN_SRC emacs-lisp
    (use-package eyebrowse :straight t 
      :config (eyebrowse-mode +1)
      )
#+END_SRC
**** Winner (Restore Window layout)
 When we are working with multiple windows open but we might maximize one window to focus
 on it, but when we are done with focus mode ;) we need that layout back that's were winner mode
 comes handy you can restore last window layout with just a function called =winner-undo= that
 by default is bound to =C-c <left>=.
 #+BEGIN_SRC emacs-lisp
   (use-package winner 
     :commands (winner-redo winner-undo))
 #+END_SRC
**** Ace Window (Better Window Management)
 #+BEGIN_SRC emacs-lisp
 (use-package ace-window
   :straight t
   :general
   (general-define-key :states 'normal "C-w" 'ace-window)
   :bind (("C-x o" . 'ace-window) 
	  ("C-x C-o" . 'ace-window)))
 #+END_SRC

* File Manager
#+begin_src emacs-lisp
  (use-package dired
    :config
    (add-hook 'dired-mode-hook (lambda () 
                                 (dired-hide-details-mode 1)))
    :bind
    (:map dired-mode-map
          ("C-c d" . dired-hide-details-mode)
          ("C-j" . next-line)
          ("C-k" . previous-line)))

  (use-package dired-sidebar :straight t
    :bind
    (("<f8>" . dired-sidebar-toggle-sidebar)))

  (use-package dired-subtree
    :straight t
    :bind (:map dired-mode-map
                ("<tab>" . dired-subtree-toggle)))

  (use-package peep-dired
    :straight t
    :after dired
    :config
    (setq peep-dired-cleanup-on-disable t)
    (setq peep-dired-enable-on-directories nil)
    (setq peep-dired-ignored-extensions
          '("mkv" "webm" "mp4" "mp3" "ogg" "iso"))
    :bind (:map dired-mode-map
                ("P" . peep-dired)))
#+end_src
* Mail & News reader
Mail setup in Emacs using Gnus.
#+begin_src emacs-lisp
  (use-package auth-source
    :custom
    (auth-sources '("~/.authinfo.gpg" "~/.authinfo")))

  (use-package gnus
    :config
    (setq gnus-thread-sort-functions
          '(gnus-thread-sort-by-number
            gnus-thread-sort-by-date))
    :custom
    (gnus-select-method '(nnnil))
    (gnus-secondary-select-methods
     '((nnimap "Gmail"
               (nnimap-address "imap.gmail.com")
               (nnimap-server-port "imaps")
               (nnimap-stream ssl))
       )))


#+end_src
* Music
I need music when I am working, so for me music is just a part of development environment, and let helm help us.
** Using Rhythmbox.el
#+begin_src emacs-lisp
  (use-package Rhythmbox.el :straight (:host github :repo "amirrezaask/Rhytmbox.el")
    :bind
    ("C-c m n" . Rhythmbox/current-song-name)
    ("C-c m p" . Rhythmbox/playpause-current-song)
    ("C-c m l" . Rhythmbox))
#+end_src
** Using counsel
#+begin_src emacs-lisp
    (use-package counsel
    :disabled t
    :straight t
    :demand
    :config
    (defun counsel-rhythmbox-playpause ()
    "Play/pause the current song."
    (require 'dbus)
    (interactive)
    (let ((service "org.gnome.Rhythmbox3")
          (path "/org/mpris/MediaPlayer2")
          (interface "org.mpris.MediaPlayer2.Player"))
      (dbus-call-method :session service path interface
                        "PlayPause")))

    :bind (("C-c m l" . counsel-rhythmbox)
           ("C-c m c" . (lambda ()
                          (interactive)
                          (message (counsel-rhythmbox-current-song))))

           ("C-c m p" . (lambda ()
                          (interactive)
                          (counsel-rhythmbox-playpause)
                          ))))
#+end_src
** Bongo
#+begin_src emacs-lisp
  (use-package bongo :straight t
    :config
    (setq bongo-prefer-library-buffers nil)
    (setq bongo-insert-whole-directory-trees t)
    (setq bongo-logo nil)
    (setq bongo-action-track-icon nil)
    (setq bongo-display-track-icons nil)
    (setq bongo-display-track-lengths nil)
    (setq bongo-display-header-icons nil)
    (setq bongo-display-playback-mode-indicator t)
    (setq bongo-display-inline-playback-progress nil)
    (setq bongo-mark-played-tracks nil)
    (setq bongo-header-line-mode nil)
    (setq bongo-header-line-function nil)
    (setq bongo-mode-line-indicator-mode nil)
    (setq bongo-default-directory "~/Music")
    (defun amirreza/dired-music-library-hook ()
      (when (string-match-p "Music" default-directory)
        (set (make-local-variable 'bongo-dired-library-mode) 't)))
  
    :hook
    (dired-mode . amirreza/dired-music-library-hook)
    :bind
    (:map bongo-dired-library-mode-map
          ("<C-return>" . bongo-insert-file)))
#+end_src
* IRC
#+begin_src emacs-lisp
  (use-package erc :defer t)
#+end_src
* Process management
#+begin_src emacs-lisp
      (use-package proced
        :commands proced)
#+end_src
* Org Mode
***** Org
#+BEGIN_SRC emacs-lisp
    (use-package org
    :straight t
    :demand
    :init
    (defun amirreza/--org-insert-elisp-code-block ()
      (interactive)
      (insert (format "#+begin_src emacs-lisp\n\n#+end_src"))
      (previous-line)
      (beginning-of-line))
    :bind (:map org-mode-map
                ("C-c c b" . amirreza/--org-insert-elisp-code-block))
    :custom
    (org-ellipsis "⤵")
    (org-src-fontify-natively t)
    (org-src-tab-acts-natively t)
    (org-support-shift-select t)
    (org-src-window-setup 'current-window)
    (org-agenda-files '("~/org/work.org" "~/org/personal.org")))
#+END_SRC
***** Org bullets
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :straight t
  :hook (org-mode . org-bullets-mode))
#+END_SRC
***** Org TOC
#+begin_src emacs-lisp
(use-package toc-org :straight t :hook (org-mode . toc-org-mode))
#+end_
* Editor
*** Defaults
***** Line width
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config
    (setq-default fill-column 80))
#+END_SRC
***** Tab
Set default tab width.
#+BEGIN_SRC emacs-lisp
(use-package emacs
    :config
    (setq-default
    indent-tabs-mode nil
    tab-width 4))
#+END_SRC
***** Encoding
Use UTF-8 everywhere.
#+BEGIN_SRC emacs-lisp
  (use-package mule
  :config 
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (prefer-coding-system 'utf-8))
#+END_SRC
*** Set a new custom file
#+BEGIN_SRC emacs-lisp
  (use-package cus-edit
    :custom
    (custom-file "~/.emacs.d/custom.el"))
#+END_SRC
*** Delete selection when inserting into it
#+begin_src emacs-lisp
(use-package delsel
  :hook (after-init . delete-selection-mode))
#+end_src
*** Show keychords more fast
when we start using modifier keys emacs shows them in minibuffer but the initial value
of the is too much so we can decrease it.
#+BEGIN_SRC emacs-lisp
(use-package emacs 
:custom
(echo-keystrokes 0.1))
#+END_SRC

*** Backup files
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (setq backup-directory-alist
          '(("." . "~/.emacs.d/backup/")))
    (setq backup-by-copying t)
    (setq version-control t)
    (setq delete-old-versions t)
    (setq kept-new-versions 6)
    (setq kept-old-versions 2)
    (setq create-lockfiles nil))
#+end_src
*** don't type yes every time
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Edit configuration
So many times when I am using Emacs I find a problem or a possible feature to add it's nice to have a keybinding that just opens this file.
#+BEGIN_SRC emacs-lisp
    (defun amirreza/edit-configuration ()
        (interactive)
        (find-file (expand-file-name "README.org" user-emacs-directory)))

    (global-set-key (kbd "C-c c e") 'amirreza/edit-configuration)
    (space-leader "e c" 'amirreza/edit-configuration)
#+END_SRC
*** Large files handling
Since Emacs by default is not that good in handling large files,
but again Emacs community is here to help
#+begin_src emacs-lisp
(use-package vlf :straight t)
#+end_src
*** Beacon
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :straight t
  :config (beacon-mode 1))
#+END_SRC

*** Some general keybindings
#+BEGIN_SRC emacs-lisp
  ;; sane zoom-in and zoom-out 
  ;; (global-set-key (kbd "C-+") 'text-scale-increase)
  ;; (global-set-key (kbd "C-_") 'text-scale-decrease)

  ;; custom motions
  (global-set-key (kbd "M-n") (lambda () (interactive) (next-line 5)))
  (global-set-key (kbd "M-p") (lambda () (interactive) (previous-line 5)))
#+END_SRC
*** Highlight matching parens
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-delay 0)
#+END_SRC
*** Reduce clutter in emacs frame
 #+BEGIN_SRC emacs-lisp
   (use-package emacs
     :config
     (if (< emacs-major-version 27) ;; from Emacs 27 this settings are moved to `early-init.el'
         (tool-bar-mode 0) ;; disable tool-bar 
       (scroll-bar-mode 0) ;; disable scroll-bar
       (menu-bar-mode 0) ;; disable menu-bar
     )
     (setq use-dialog-box nil) ;; ask quesions in minibuffer
     (setq inhibit-splash-screen 0) ;; disable startup screen
     (setq ring-bell-function 'ignore) ;; don't make a sound
     (defalias 'yes-or-no-p 'y-or-n-p) ;; instead of yes/no ask y/n
     )
 #+END_SRC
*** Some informative numbers
#+BEGIN_SRC emacs-lisp
   (use-package display-line-numbers
     :config
     (global-display-line-numbers-mode +1))
   (use-package simple
     :config
     (column-number-mode +1))
#+END_SRC
*** Some cursor tweaks
#+BEGIN_SRC emacs-lisp
   (use-package emacs
     :config
     (setq-default cursor-type 'box))
   (use-package frame
     :config
     (blink-cursor-mode +1))
   (use-package hl-line
     :config
     (global-hl-line-mode +1))

 #+END_SRC
*** Interactive Edit(IEdit)
 Edit multiple occurrences of a text.
 #+BEGIN_SRC emacs-lisp
   (use-package iedit
		:straight t
		:bind (("C-;" . 'iedit-mode)))
 #+END_SRC
*** Interactive Buffer Management
Ibuffer is a built in Emacs package that helps you manage your open buffers a in a interactively
designed interface.
#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :bind (("C-x C-b" . 'ibuffer))
  :general
  (space-leader-lord "i b" 'ibuffer))
#+END_SRC
=Ibuffer-projectile= provides ibuffer integration with projectile to seperate buffers that belong
to different git repos in the Ibuffer view.
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-projectile 
    :straight t
    :hook (ibuffer . ibuffer-projectile-set-filter-groups))

#+END_SRC
*** Multiple Cursors
 For scenarios that IEdit does not work we are going to use Multiple cursors.
 #+BEGIN_SRC emacs-lisp
 (use-package multiple-cursors
   :straight t
   :bind (("C->" . 'mc/mark-next-like-this)
	  ("C-<" . 'mc/mark-previous-like-this)
	  ("C-c C-<" . 'mc/mark-all-like-this)
	  ("C-M-," . 'mc/edit-lines)))
 #+END_SRC
*** Jump to defenition
 Although we are going to setup LSP (Language Server Protocol) and that provides so many features
 like jump to defenition but for simpler use cases we can use =dumb jump= which provide jump to 
 defenition feature using rg/ag.
 #+BEGIN_SRC emacs-lisp
   (use-package dumb-jump
     :straight t
     :bind
     (("C-M-j" . 'dumb-jump-go)
      ("C-M-p" . 'dumb-jump-back))
     :config
     (dumb-jump-mode 1))
 #+END_SRC
*** Highlight TODOs
 Highlight TODO/FIXME/... in text.
 #+BEGIN_SRC emacs-lisp
 (use-package hl-todo
   :straight t
   :hook ((prog-mode) . hl-todo-mode)
   :config
   (setq hl-todo-highlight-punctuation ":"
	 hl-todo-keyword-faces
	 `(("TODO"       warning bold)
	   ("FIXME"      error bold)
	   ("HACK"       font-lock-constant-face bold)
	   ("REVIEW"     font-lock-keyword-face bold)
	   ("NOTE"       success bold)
	   ("DEPRECATED" font-lock-doc-face bold))))
 #+END_SRC
*** Kill ring
Emacs kill ring is Emacs way of doing clipboard
#+begin_src emacs-lisp
    (use-package simple
      :custom
      (kill-ring-max 15))
#+end_src
*** Expand Region
 A selected text is called region in Emacs, expand region helps you expand this region based
 semantics.
 #+BEGIN_SRC emacs-lisp
   (use-package expand-region
     :straight t
     :bind (("C-=" . 'er/expand-region)
	    ("C--" . 'er/contract-region)))
 #+END_SRC
*** Sudo Edit
 Edit root owned files in emacs without restarting Emacs.
 #+BEGIN_SRC emacs-lisp
   (use-package sudo-edit
		:commands (sudo-edit))
 #+END_SRC
*** Highlight Indents
 #+BEGIN_SRC emacs-lisp
 (use-package highlight-indent-guides
   :straight t
   :hook ((yaml-mode) . highlight-indent-guides-mode)
   :init
   (setq highlight-indent-guides-method 'character)
   :config
   (add-hook 'focus-in-hook #'highlight-indent-guides-auto-set-faces))
 #+END_SRC
*** Improve Scrolling
 #+BEGIN_SRC emacs-lisp
   (use-package emacs
     :custom
     ; vertical scrolling
     (scroll-step 1)
     (scroll-margin 1)
     (scroll-conservatively 101)
     (scroll-up-aggressively 0.01)
     (scroll-down-aggressively 0.01)
     (auto-window-vscroll nil)
     (fast-but-imprecise-scrolling nil)
     (mouse-wheel-scroll-amount '(1 ((shift) . 1)))
     (mouse-wheel-progressive-speed nil)
     ;; Horizontal Scroll
     (hscroll-step 1)
     (hscroll-margin 1))
 #+END_SRC
*** Which key
Now you probably agree with me that Emacs has a lot of keybindings and sometimes you just feel
lost, that's when which key comes in, when you just remember part of keybinding which shows you a
prompt of available options and their respective functionality.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :straight t
    :custom
    (which-key-idle-delay 0.3)
    :config
    (which-key-mode 1))
#+END_SRC
*** Dumb Jump
Sometimes when you are dealing with really big projects LSP can feel a little slow so that's
when dumb jump can help you jump to defenitions using Rg or ag or grep (we use Rg)
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :straight t
    :general
    (space-leader "." 'dumb-jump-go "/" 'dumb-jump-back)
    :custom
    (dumb-jump-selector 'ivy)
    :bind
    (("C-M-j" . 'dumb-jump-go)
     ("C-M-p" . 'dumb-jump-back))
    :config
    (dumb-jump-mode 1))
#+END_SRC

*** Searching
There are two tools that I think are amazing when it comes to searching, for text =ripgrep= is
the fastest and easiest one out there, and for files is =FZF=, let's integrate those two in Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package isearch
    :demand
    :custom
    (isearch-highlight t)
    (isearch-whitespace-regexp ".*?")
    (isearch-lax-whitespace t)
    (isearch-regexp-lax-whitespace nil)
    (isearch-lazy-highlight t)
    :bind 
    (("C-s" . isearch-forward-regexp) ;; map default C-s to regex search
     ("C-r" . isearch-backward-regexp)
     ("C-M-s" . isearch-forward)
     ("C-M-r" . isearch-backward)))


  (use-package fzf
    :straight t
    :bind
    (("<f6> f" . fzf-directory)))

  (use-package rg
   :straight t
   :bind (("<f6> g" . rg)))

#+END_SRC
*** Atomic Typing
Every human being has limited number of keystrokes left, so let's make every one of them count.
Abbrev mode is Emacs internal that expands on defined abbrevations,
Abbrev mode is really helpful but in more complicated scenarios we need more smart tool,
so we use skeleton mode and we combine that with abbrev mode to get maximum power, we are 
going to define our skeletons in their respective languages. Snippet macro defines a new snippet,
Snippets are basically combination of abbrevs and skeletons, abbrevs are used for triggering
skeleton and skeleton does it's job of inserting text.
#+begin_src emacs-lisp
      (use-package abbrev
        :demand 
        :bind (("C-x '" . expand-abbrev)))

      (use-package skeleton :demand
        :config
        (defmacro amirreza/defsnippet (abbrv &rest skeleton-expansions)
          "Snippets are wrapper around skeleton and abbrevs."
          (let ((command-name (intern (format "amirreza/snippet-%s" abbrv))))
            `(progn
               (define-skeleton ,command-name ""
                 ,@skeleton-expansions)
               (define-abbrev local-abbrev-table ,abbrv "" (quote ,command-name))))))
#+end_src
*** Rainbow delimiters
Highlight matching brackets in matching colors
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters :straight t :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
*** Rainbow Blocks
although =Rainbow-delimiters= shows us the start and end of an list, but it's nice to be able to see more.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-blocks :straight t :defer t)
#+END_SRC
* Selection Candidates
Narrowing frameworks in Emacs are tools that help us when we want to choose an option from list of options, and this scenario
happens a lot in Emacs.
*** Icomplete
#+BEGIN_SRC emacs-lisp
    (use-package icomplete
      :demand ;loading of icomplete is not deferred since we are using `:bind'.
      :custom
      (icomplete-max-delay-chars 0)
      (icomplete-compute-delay 0.2)
      (icomplete-show-matches-on-no-input t) ;; show completions from start of entering the minibuffer
      (icomplete-separator " | ") ;; seperator of candidates
      (icomplete-hide-common-prefix nil) ;;
      (icomplete-with-completion-tables t) ;; do completion on anything that has a completion table
      (icomplete-in-buffer nil) ; we dont want icomplete to work in buffers, we have company for that
      (completion-styles '(flex))
      :config
      (defun amirreza/show-kill-ring ()
        (interactive)
        (insert (completing-read "Choose: " kill-ring )))

      (when (> emacs-major-version 27)
        (fido-mode -1))
      (icomplete-mode +1)
      :bind (("M-y" . amirreza/show-kill-ring)
             :map icomplete-minibuffer-map
                  ("C-f" . icomplete-forward-completions)
                  ("C-b" . icomplete-backward-completions)
                  ("C-n" . icomplete-forward-completions)
                  ("C-p" . icomplete-backward-completions)
                  ("<right>" . icomplete-forward-completions)
                  ("<left>" . icomplete-backward-completions)
                  ("<up>" . icomplete-backward-completions)
                  ("<RET>" . icomplete-force-complete-and-exit)
                  ("<down>" . icomplete-forward-completions)))

    (use-package icomplete-vertical
      :straight t
      :demand
      :config
      (icomplete-vertical-set-separator "\n----------\n")
      (icomplete-vertical-mode 1)
      :bind
      (:map icomplete-minibuffer-map
            ("C-t" . icomplete-vertical-toggle)))

#+END_SRC
*** IDO
#+BEGIN_SRC emacs-lisp
  (use-package ido
    :disabled t
    :config
    (ido-mode 1)
    (ido-everywhere 1)
    (setq ido-enable-flex-matching t))

  (use-package ido-vertical-mode
    :disabled t
    :config
    (ido-vertical-mode 1)
    (setq ido-vertical-define-keys 'C-n-and-C-p-only))

  (use-package ido-completing-read+
    :disabled t
    :config
    (ido-ubiquitous-mode 1))

#+END_SRC
*** Ivy
#+BEGIN_SRC emacs-lisp
  (use-package flx  :disabled t :straight t)
  (use-package ivy
    :disabled t
    :straight t
    :custom
    (ivy-height 9)
    (ivy-wrap t)
    (ivy-fixed-height-minibuffer t)
    (projectile-completion-system 'ivy)
    ;; disable magic slash on non-match
    (ivy-magic-slash-non-match-action nil)
    ;; don't show recent files in switch-buffer
    (ivy-use-virtual-buffers nil)
    ;; ...but if that ever changes, show their full path
    (ivy-virtual-abbreviate 'full)
    ;; don't quit minibuffer on delete-error
    (ivy-on-del-error-function #'ignore)
    ;; enable ability to select prompt (alternative to `ivy-immediate-done')
    (ivy-use-selectable-prompt t)

    :config
    (setf (alist-get 't ivy-format-functions-alist)
          #'ivy-format-function-line)
    (ivy-mode +1)

    :bind
    (("C-x b" . 'ivy-switch-buffer)
     :map ivy-minibuffer-map
     ("C-j" . 'ivy-next-line)
     ("C-k" . 'ivy-previous-line)
     ("RET" . 'ivy-alt-done)

     :map ivy-switch-buffer-map
     ("C-j" . 'ivy-next-line)
     ("C-k" . 'ivy-previous-line)))

  (use-package swiper
    :disabled t
    :straight t
    :commands (swiper)
    :init (global-set-key (kbd "C-s") 'swiper))

  (use-package counsel
    :disabled t
    :straight t
    :commands (counsel-M-x counsel-find-file ivy-switch-buffer)
    :custom
    (ivy-re-builders-alist
     '((t . ivy--regex-fuzzy)))
    :general 
    (space-leader "s s" 'counsel-rg "s f" 'counsel-fzf)
    :bind
    (("M-x" . 'counsel-M-x)
     ("C-x C-f" . 'counsel-find-file)
     ("C-h b" . 'counsel-descbinds)
     ("C-h f" . 'counsel-describe-function)
     ("C-h v" . 'counsel-describe-variable)
     ("C-h a" . 'counsel-apropos)
     ("<f6> s" . 'counsel-rg)
     ("<f6> f" . 'counsel-fzf)
     ( "M-y" . 'counsel-yank-pop)))
#+END_SRC
*** Helm
 #+begin_src emacs-lisp
      (use-package helm :straight t
        :disabled t
        :custom
        (helm-mode-fuzzy-match t) ;; enable fuzzy matching in all helm
        :general
        (:keymaps 'helm-map
                  "C-j" 'helm-next-line
                  "C-k" 'helm-previous-line
                  "<tab>"  'helm-execute-persistent-action   ;; make tab work normal
                  "C-z"  'helm-select-action) ;; C-z instead of tab to show helm actions

        (:keymaps 'override
                  "M-y" 'helm-show-kill-ring
                  "M-x" 'helm-M-x
                  "C-s" 'helm-occur)

        (:keymaps 'override
                  "<f6> g" 'helm-rg)

        (:prefix "C-h"
                 "a" 'helm-apropos
                 "f" 'helm-apropos
                 "k" 'helm-apropos
                 "v" 'helm-apropos
                 )
        (:prefix "C-x" :keymaps 'override
                 "C-f" 'helm-find-files
                 "b" 'helm-mini
                 "C-b" 'helm-mini
                 )
        (space-leader-lord
          "h a" 'helm-apropos
          "f f" 'helm-find-files
          ";" 'helm-M-x
          "l l" 'helm-mini
          "b l" 'helm-mini))

    (use-package helm-descbinds :straight t
      :disabled t
      :bind (("C-h b" . helm-descbinds)))

    (use-package helm-describe-modes :straight t
    :disabled t
    :bind (("C-h m" . helm-describe-modes)))

   (use-package helm-make :straight t
    :disabled t
    :bind (("<f5> m" . helm-make)))
 #+end_src
* Completion
Code completion consists of two parts, A source/server that provides the completions and 
an engine that knows when to open prompt and show the completions. We will configure servers later
but now we need to install the engine that shows us the completion.
=Company-mode= in my opinion is the best one out there, it consists of =backends= and =frontends=
backends connect to multiple tools that provide the completions and frontends are about the GUI.
Since we are going to use LSP as the main source for the completions we just need the default 
configuration of company.
For company backends we are going to use =company-capf= which is abbrv for =company complete at point function= which is a function in Emacs that major modes
can call an get completions based on that.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :demand
    :straight t
    :custom
    (company-minimum-prefix-lenght 1)
    (company-tooltip-limit 30)
    (company-idle-delay 0.0)
    (company-echo-delay 0.1)
    (company-backends '(company-capf company-dabbrev company-files company-dabbrev-code))
    :bind (:map company-active-map
                ("C-n" . company-select-next)
                ("C-p" . company-select-previous)
                ("C-o" . company-other-backend)
                ("<tab>" . company-complete-common-or-cycle)
                ("RET" . company-complete-selection))
    :config
    (defmacro amirreza/with-backends (mode backends) 
      "Register a buffer local variable with given BACKENDS for given MODE. For registering backends for various modes use this"
      (let ((mode-hook (intern (concat (symbol-name mode) "-hook"))))
        (message "amirreza/with-backends called with %s %s %s" mode backends mode-hook)
        `(add-hook (quote ,mode-hook) (lambda ()
                                        (setq-local company-backends (quote ,backends))))))
    (global-company-mode t))


#+END_SRC
* Integrated Development Environment
IDE means =Integrated Development Environment= basically a software provides you with every thing you need when you are developing software, and since Emacs is such a extensible platform
turning Emacs into an IDE is not that hard.
*** Terminal Emulator
**** VTerm
     #+BEGIN_SRC emacs-lisp
       (use-package vterm
         :straight t
         :commands vterm
         :bind (("<f10>" . vterm)))

#+END_SRC
*** Language Server Protocol
Language Server protocol is a open source protocol developed by microsoft but now it's being
developed by community, it defines a communication protocol that a lanaguge server (let's say gopls)
can talk to various clients (let's say Emacs, Vi, VSCode) and provide several features such
as auto-complete or syntax linting.
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode 
    :straight t
    :commands (lsp lsp-deferred)
    :hook 
    ((python-mode
      go-mode) . lsp)
    :custom
    (lsp-auto-guess-root t)
    :general
    (space-leader-lord "." 'xref-find-definitions)
    :commands (lsp))


(use-package dap-mode :straight t)
(use-package helm-lsp :disabled t :straight t :commands helm-lsp-workspace-symbol)

#+END_SRC
LSP-ui is a mode from the same author with the goal of configuring several Emacs packages to 
help ease developer experience when using LSP.
#+BEGIN_SRC emacs-lisp
  ;; (use-package lsp-ui :straight t :commands lsp-ui-mode :hook (lsp-mode . lsp-ui-mode))
#+END_SRC
*** Git integration
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :straight t
    :commands (magit-status)
    :general 
    (space-leader "g s" 'magit-status)
    :bind
    (("C-x g" . 'magit-status)))

  (use-package diff-hl
    :straight t
    :config (global-diff-hl-mode 1))

  (use-package
    gitconfig-mode
    :straight t
    :mode "/\\.gitconfig\\'")

  (use-package gitignore-mode
    :straight t
    :mode "/\\.gitignore\\'")

  (use-package gitattributes-mode
    :straight t
    :mode "/\\.gitattributes\\'")

  (use-package git-messenger
    :straight t
    :bind
    (("<f1> g" . git-messenger:popup-message))
    :config
    (setq git-messenger:show-detail t)
    (setq git-messenger:use-magit-popup t))

#+END_SRC
*** Syntax checking
Emacs comes with a built in syntax checker called =flymake=, but since emacs community favors =flycheck= over =flymake= we are going to setup flycheck.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :straight t
    :hook (prog-mode . flycheck-mode))
#+END_SRC
*** Debugger Support
TBA
*** Docs
#+begin_src emacs-lisp
  (use-package eldoc
    :hook (prog-mode . eldoc-mode))
#+end_src
*** Project Detection
=projectile= is a package that notifies when you open something in a git repository and can
provide several feature to other packages or to the user directly.
#+BEGIN_SRC emacs-lisp
(use-package projectile
       :bind
       (("C-x p" . 'projectile-command-map)
        ("C-c p" . 'projectile-add-known-project))
       :config
       (projectile-mode 1))

#+END_SRC
* Programming Languages
** Python
*** Python Mode
Emacs itself comes with =python-mode= which is python major mode that provides emacs with 
syntax highlighting and some other features on python, so we just need to configure it the way 
we want. I added some custom python functions to suit my python needs like the docstring function
that inserts a docstring in python syntax.
#+BEGIN_SRC emacs-lisp
  (use-package python-mode
    :mode "\\.py\\'"
    :config
    (defun amirreza/python-insert-docstring ()
      (interactive)
      (insert "'''\n'''")
      (previous-line))
    (amirreza/with-backends python-mode (company-capf))
    :bind
    (:map python-mode-map 
      ("C-c l p d" . amirreza/python-insert-docstring)))
#+END_SRC
*** Microsoft Language Server
#+begin_src emacs-lisp
(use-package lsp-python-ms :straight t)
#+end_src
*** Pipenv
=Pipenv= is now the de facto tool for python programmers to manage their project deps, so it's nice
to have a wrapper for it in Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package pipenv
	       :straight t
	       :defer t)
#+END_SRC
*** Py-autopep8
We are using LSP for all our IDE like features but right now python lanugage server does not
provide formmatting feature for python so we need to use another package called =py-autopep8= which
actually is just a wrapper around python package that you need to install from =pypi= called 
no suprises =py-autopep8=. We install this package and we need this package to hook it's format 
function to =before-save-hook= of emacs, luckily this package provides a helper function to do that.
#+BEGIN_SRC emacs-lisp
(use-package py-autopep8
  :straight t
  :hook python-mode
  :config
  (py-autopep8-enable-on-save))

#+END_SRC
** Go
*** Go-mode
Golang by default is not supported in Emacs, but don't fear, we can fix that by simply installing
=go-mode= which is a major mode and it provides the basic syntax highlighting that we need, we also
need to configure this package to enable some LSP features that are necessary like formatting. For
go to work perfectly you need to add the =GOPATH= to your =exec-path= to let emacs find go binaries
that it needs.
#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :straight t
    :mode ("\\.go\\'" . go-mode)
    :init
    (defun amirreza/go-snippets ()
      (amirreza/defsnippet "fmain" "" "func main() {" \n "}")
      (amirreza/defsnippet "pkgm" "Package: " "package " str \n)
      (amirreza/defsnippet "pl" "" "fmt.Println(\"" _ "\")") ;; _ is the cursor position after the expansion
      (amirreza/defsnippet "pf" "" "fmt.Printf(\"" _ "\")"))
    (add-hook 'go-mode-hook (lambda () (add-to-list 'exec-path (concat (getenv "HOME") "/go/bin"))))
    (add-hook 'go-mode-hook 'amirreza/go-snippets)
    :config
    (amirreza/with-backends go-mode ((company-capf company-tabnine)))
    (add-hook 'go-mode-hook (lambda () 
                              (interactive)
                              (setq-local prettify-symbols-alist '(("func" . 955) ; λ
                                                                   ))))
    (add-hook 'go-mode-hook (lambda () (interactive)
                              (add-hook 'before-save-hook 'lsp-format-buffer t t)
                              (add-hook 'before-save-hook 'lsp-organize-imports t t))))
#+END_SRC
*** Go-add-tags
it's always a pain to manually add struct tags for a struct specially when
the struct has so many fields, again thanks to the emacs community we have package for that 
to ease that task for us.
#+BEGIN_SRC emacs-lisp
  (use-package go-add-tags :straight t :defer t :bind (:map go-mode-map ("C-c C-g s t" . go-add-tags)))
#+END_SRC
*** Go-test
=VSCode= has a great support when it comes to running go tests, it gives you the ability to 
run a test when you are editing or viewing it but it does'nt mean that Emacs can't do that.
#+BEGIN_SRC emacs-lisp
  (use-package gotest :defer t :straight t :bind (:map go-mode-map ("C-c t f" . go-test-current-file) ("C-c t t" . go-test-current-test)))
#+END_SRC
** Scheme
I use guile as my scheme compiler.
#+begin_src emacs-lisp
  (use-package scheme
  :custom
  (scheme-program-name "guile"))
#+end_src
** GS (Go Scheme)
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.gs\\'" . scheme-mode))
#+end_src
** Elisp
Emacs lisp should be supported by default ha ? actually it has almost all support you need but 
we can even go further.x
#+BEGIN_SRC emacs-lisp
  (use-package elisp-mode
    :config
    (setq-local prettify-symbols-alist '(("fn" . 955)))
    (defun --amirreza/emacs-lisp-repeat (str count)
      "Create dashes with given COUNT."
      (let ((dashes ""))
    (dotimes (iterator count dashes)
      (setq dashes (concat dashes str)))))

    (defun --amirreza/emacs-lisp-wrap-text-in-spaces (text)
      (let* ((len (length text))
         (spaces-length-side (/ (- 80 len) 2))
         (spaces-side (--amirreza/emacs-lisp-repeat " " spaces-length-side)))
    (format "%s%s%s" spaces-side text spaces-side)))

    (defun amirreza/emacs-lisp-insert-comment-line (text)
      "Insert a comment line with given TEXT."
      (interactive "sComment: ")
      (let* ((text-wrapped (--amirreza/emacs-lisp-wrap-text-in-spaces text))
         (dashes (--amirreza/emacs-lisp-repeat "=" 80)))
    (insert (format "\n;;%s\n;;%s\n;;%s" dashes text-wrapped dashes))))
    :general
    (:keymaps 'emacs-lisp-mode-map :states 'normal "; d b" 'amirreza/emacs-lisp-insert-comment-line)
    :bind
    (:map emacs-lisp-mode-map
      ("C-c C-c C-d" . 'amirreza/emacs-lisp-insert-comment-line)))

#+END_SRC
** Clojure
*** Clojure Mode
    #+BEGIN_SRC emacs-lisp
              (use-package clojure-mode :straight t
                :config
                (setq-local prettify-symbols-alist '(("fn" . 955) ; λ
                                                      ("->" . 8594))))
    #+END_SRC
*** Cider
#+BEGIN_SRC emacs-lisp
  (use-package cider 
    :straight t
    :commands (cider cider-jack-in)
    :bind (:map cider-mode-map ("C-x C-e" . cider-eval-last-sexp))
    )
#+END_SRC
** Common Lisp
*** Common-lisp mode
#+BEGIN_SRC emacs-lisp
(use-package lisp-mode :mode "\\.cl\\'")
#+END_SRC
*** Common Lisp Integrated Environment
#+BEGIN_SRC emacs-lisp
(use-package sly :straight t)
#+END_SRC
** Haskell
*** Haskell mode
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode :straight t :mode "\\.hs\\'")
#+END_SRC
*** Haskell IDE engine
#+BEGIN_SRC emacs-lisp
(use-package lsp-haskell :straight t :hook haskell-mode)
#+END_SRC
** HTML/CSS
#+BEGIN_SRC emacs-lisp
  (use-package web-mode :straight t :mode ("\\.html\\'" "\\.css\\'"))
#+END_SRC
** PHP
*** PHP mode
#+BEGIN_SRC emacs-lisp
(use-package php-mode :straight t :mode "\\.php\\'")
#+END_SRC
*** PHP Runtime Integration
#+BEGIN_SRC emacs-lisp
(use-package php-runtime :straight t :defer t)
#+END_SRC
*** Composer Integration
#+BEGIN_SRC emacs-lisp
(use-package composer :straight t :hook php-mode)
#+END_SRC
*** PHPUnit
#+BEGIN_SRC emacs-lisp
(use-package phpunit :straight t :commands (php-current-test php-current-class php-current-project))
#+END_SRC
** Rust
*** Rust mode
#+BEGIN_SRC emacs-lisp
(use-package rust-mode :straight t :mode "\\.rs\\'")
#+END_SRC
* Devops
*** Some syntax highlights
#+begin_src emacs-lisp
  (use-package crontab-mode :defer t :straight t)
  (use-package apache-mode :straight t
    :mode ("\\.htaccess\\'" "httpd\\.conf\\'" "srm\\.conf\\'" "access\\.conf\\'"))
  (use-package systemd :straight t
    :mode ("\\.service\\'" "\\.timer\\'"))
  (use-package nginx-mode :straight 
    :mode ("/etc/nginx/conf.d/.*" "/etc/nginx/.*\\.conf\\'"))
#+end_src
*** TRAMP
#+begin_src emacs-lisp
  (use-package tramp
        :custom
        (tramp-default-method "ssh"))
#+end_src
*** Docker
#+BEGIN_SRC emacs-lisp
(use-package docker-compose-mode
  :straight t
  :defer t)
#+END_SRC
*** Kubernetes
#+begin_src emacs-lisp
(use-package kubel :straight t :commands (kubel) :bind (("<f9>" . kubel)))
#+end_src
*** Redis
#+begin_src emacs-lisp
(use-package redis :straight t)
#+end_src

* Games
** Pacman
#+begin_src emacs-lisp
(use-package pacmacs :straight t :defer t)
#+end_src
