#+TITLE: AmirrezaAsk Emacs configuration
#+AUTHOR: amirrezaask
* Table Of contents                                                     :TOC@4:
- [[#introduction][Introduction]]
- [[#what-is-emacs-][What is Emacs ?]]
  - [[#editor--ide--mail-client--window-manager--terminal-emulator--lisp-interpreter--all-of-them--none-][Editor ? IDE ? Mail client ? Window manager ? Terminal emulator ? Lisp interpreter ? all of them ? none ?]]
- [[#ascend-from-darkness][Ascend from darkness]]
  - [[#installing-emacs][Installing Emacs]]
  - [[#let-your-feet-get-wet][Let your feet get wet]]
    - [[#opening-a-file][Opening a file]]
    - [[#motions][Motions]]
    - [[#emacs-is-self-documenting][Emacs is self documenting]]
    - [[#elisp][Elisp]]
      - [[#hello-world][Hello World]]
      - [[#loading-evaluating-file][Loading (Evaluating) file]]
  - [[#emacs-modes-introduction][Emacs Modes Introduction]]
  - [[#start-your-configuration][Start Your configuration]]
  - [[#introducing-emacs-27][Introducing Emacs 27]]
- [[#personal-information][Personal information]]
  - [[#gc][GC]]
  - [[#file-name-handler-alist][file-name-handler-alist]]
- [[#debug-when-necessary][Debug When necessary]]
- [[#package-manager-setup][Package manager setup]]
- [[#about-this-configuration][About this configuration]]
  - [[#disabled-packages][Disabled packages]]
  - [[#keybinding-conventions][Keybinding conventions]]
- [[#chapters][Chapters]]
  - [[#keybinding-helper-packages][Keybinding helper packages]]
  - [[#ui][UI]]
    - [[#themes][Themes]]
    - [[#some-cursor-tweaks][Some cursor tweaks]]
    - [[#font][Font]]
    - [[#icons][Icons]]
    - [[#modeline][Modeline]]
  - [[#windowsworkspaces][Windows/Workspaces]]
    - [[#window-rules][Window rules]]
    - [[#eyebrowse][Eyebrowse]]
    - [[#winner-restore-window-layout][Winner (Restore Window layout)]]
    - [[#ace-window-better-window-management][Ace Window (Better Window Management)]]
    - [[#beacon][Beacon]]
  - [[#minibuffer-completion][Minibuffer completion]]
  - [[#editor][Editor]]
    - [[#defaults][Defaults]]
    - [[#custom-motions][Custom motions]]
    - [[#isearch][Isearch]]
    - [[#fuzzy-file-finder][Fuzzy file finder]]
    - [[#ripgrep][Ripgrep]]
    - [[#dumb-jump][Dumb Jump]]
    - [[#org-mode][Org mode]]
      - [[#org][Org]]
      - [[#org-bullets][Org bullets]]
      - [[#org-toc][Org TOC]]
      - [[#htmlize][htmlize]]
    - [[#highlight-indentation][Highlight indentation]]
    - [[#sudo-edit][Sudo edit]]
    - [[#expand-region][Expand region]]
    - [[#highlight-todofixme][Highlight TODO/FIXME/...]]
    - [[#multiple-cursors][Multiple cursors]]
    - [[#ibuffer][IBuffer]]
    - [[#iedit][Iedit]]
    - [[#vlf-very-large-file][Vlf (very large file)]]
    - [[#abbrevsskeleton][Abbrevs/Skeleton]]
    - [[#rainbow-delimiters][Rainbow delimiters]]
    - [[#avy][Avy]]
    - [[#edit-configuration][Edit configuration]]
    - [[#editor-hydra][Editor Hydra]]
  - [[#ide-setup][IDE setup]]
    - [[#add-executable-paths][Add executable paths]]
    - [[#code-completion][Code completion]]
    - [[#language-server-protocol][Language Server Protocol]]
    - [[#git-integration][Git integration]]
    - [[#syntax-checking][Syntax checking]]
    - [[#debugger-support][Debugger Support]]
    - [[#docs][Docs]]
    - [[#programming-languages][Programming languages]]
      - [[#python][Python]]
      - [[#go][Go]]
      - [[#scheme][Scheme]]
      - [[#zig][Zig]]
      - [[#emacs-lisp][Emacs lisp]]
      - [[#clojure][Clojure]]
      - [[#common-lisp][Common Lisp]]
      - [[#haskell][Haskell]]
      - [[#htmlcss][HTML/CSS]]
      - [[#php][PHP]]
      - [[#rust][Rust]]
  - [[#integrated-toolsfunctionality][Integrated tools/functionality]]
    - [[#file-manager][File Manager]]
    - [[#mail--news-reader][Mail & News reader]]
    - [[#irc][IRC]]
    - [[#process-management][Process management]]
    - [[#music][Music]]
    - [[#ide-hydra][IDE Hydra]]
  - [[#devops-tools][Devops Tools]]
    - [[#some-syntax-highlights][Some syntax highlights]]
    - [[#tramp][TRAMP]]
    - [[#docker][Docker]]
    - [[#kubernetes][Kubernetes]]
- [[#benchmark-startup-time][Benchmark startup time]]

* Introduction
=Emacs= is one of the oldest softwares that has active development and community after 40 years passed from the initial release, but why is
that ? Why when there battries included, easy to use, full-featured solutions like =VSCode=, =Jetbrains IDEA= (I mean whole Jetbrains family),
 =Atom=, =Sublime=, etc... people still use =Emacs=, What is the reason that keeps these programs alive? Is it just some people want to look
cool ? Or is there really something ? We are going to take a journey into the deepest parts of EMACS and find the answer.
* What is Emacs ?
** Editor ? IDE ? Mail client ? Window manager ? Terminal emulator ? Lisp interpreter ? all of them ? none ?
At the 70s at =MIT= AI lab computers were running an editor called =TECO= which was modal editor, as the time passed
problems of =TECO= started to create the need for a new editor paradigm, and one new implemention
 catched on very well, guy named =Fred Wright= created an editor called =E=, which was much more similar to modern
editors we know, and Stallman added same functionality to =TECO= program.
At the year 1984 =Stallman= Sta[INC]
So Emacs is an editor implemented in Emacs-lisp which is an Lisp dialect implemented in C, so basically Emacs is
a Lisp interpreter which happens to have a editor inside as well. All editor functionality is written in pure emacs-lisp
or they have the API for emacs-lisp so you can change them, you can actually change almost anything in Emacs since
every thing is a function or a variable defined in Emacs-lisp and evaluated using Emacs internal lisp evaluator and 
Emacs-lisp like many lisps has no function scoping, in simpler terms there is no private functions or variables so 
you can change the most core parts of EMACS easily with just redefining them.
* Ascend from darkness
** Installing Emacs
Installing Emacs is easy, if you are on a =GNU/Linux= distro you should be able to get it from the package manager and
in =macOS= it's available in =homebrew= and you can download windows version from gnu/emacs website.
** Let your feet get wet
*** Opening a file
Open up Emacs, what you see is a tedious white screen with an ugly Emacs logo and some links for tutorials on Emacs
(these links are actually useful take a look at them). First let's get on the same page, from this point to the
end of the document =C= in keybindings refers to control key and =M= refers to Meta(Alt) key, =S= is shift and =s= 
is super key. Open a file by pressing =<C-x C-f>=, you get a prompt to enter a file name, enter some random file name
an hit enter, file is opened and you can see the content. Let's create a table to remember the keychords we are using

| Keychord | functionality |
| C-x C-f  | opens a file  |

*** Motions
Let's move around, ofcourse you can use the mouse and click around or the arrow keys but there are more efficient
ways doing this, Just press =<C-f>= you see your cursor moves forward by a character, now press =<C-b>= and your 
cursor moves backward by a character so lets update our table. Remember there are so much more in motions these two
were just examples.

| Keychord | functionality                 |
| C-f      | moves forward by a character  |
| C-b      | moves backward by a character |

*** Emacs is self documenting
Do you remember that I told you in Emacs every thing is just an Elisp(Emacs-lisp) function, let's discuss that.
Let me introduce you to the Emacs self documenting feature, press =<C-h k>=, you should be prompted then enter
=<C-x C-f>= a new window(we'll discuss this concept later), you see a document that tolds you what this keychord
is bound to and the documentation of that function, in this case you should see that =<C-x C-f>= is bound to 
=find-file= command and you have the option to see the actual source code of that function. =<C-h>= is the prefix 
for all Emacs help commands and these keys themselves runs elisp functions you can actually do the =<C-h k>=
on itself and see the function behind it so let's update our table and from now on we write the actual function name 
in our table.

| Keychord | function          |
|----------+-------------------|
| C-h k    | describe-key      |
| C-h f    | describe-function |
| C-h v    | describe-variable |

*** Elisp
I'm not going to do a complete tutorial on Elisp just gonna tell you how you can stay alive in Emacs.
**** Hello World
Elisp or Emacs-Lisp is the language that almost all Emacs functions are written in, so let's tip our toes in it as 
well.
Open up a new file ( you already know how to do that ) name that anything but with the extension of =.el=.
at the first line write the following 
#+BEGIN_SRC 
(message "Hello World")
#+END_SRC
and then move your cursor to the end of the line using =<C-e>= and then press =<C-x C-e>=, now look at the =minibuffer=
you see the ="Hello World"= in there. Don't forget to =describe-key= the two keychords that you just used.
**** Loading (Evaluating) file
:PROPERTIES:
  :header-args: :tangle no
  :END:
You can evaluate eLisp expressions like you now know but you also can load a whole elisp file using =load-file= function
#+BEGIN_SRC 
(load-file "file.el")
#+END_SRC

** Emacs Modes Introduction
 First let's talk about modes, Modes are the conventional way to add functionality to Emacs.
 There are two groups of modes, Major modes and minor modes, Major modes are single modes that 
 get's loaded with a specific file extension, and they provide basic syntax highlighting.
 but minor modes are modes that can be loaded together for a buffer, so each buffer has a single 
 major mode, and multiple minor modes that added different abilities to emacs for a buffer.
 Forexample line numbers is a minor mode that is enabled globally for all buffers so all buffers
 show line numbers.
 Now that we have cool looks, 
** Start Your configuration
 Emacs configuration is nothing other than a simple elisp file that emacs loads at the startup we can specify that
 using =-l= flag to load specific file. so let's do that. Open an elisp file and name that =config.el=, and just put
 a simple hello world message in it, now go to terminal and enter =emacs -l config.el= when this instance of emacs starts
 up =switch-to-buffer= (this is a function you can describe-function it and find the keybindings little exercise)
 to the buffer called =*Messages*= and you should see your message in that buffer somewhere.
 Now you can write any elisp code in your config.el file and emacs always evaluates them as long as you pass the
 -l flag, but the conventional way of doing emacs configuration is using =~/.emacs.d/init.el= file which emacs 
 automatically loads in the startup, it's kind of the default file for this purpose.

** Introducing Emacs 27
Emacs 27 has a lot to offer, a new json parser that is implemented natively (C code) so it should speed
up the JSON based operations like LSP a lot, another thing about Emacs 27 is =early-init.el= file that gets
loaded before init.el and before GUI and package manager starts so it can help us configure Emacs even further.

* Personal information
#+begin_src emacs-lisp
    (setq user-full-name "AmirrezaAskarpour"
          user-mail-address "raskarpour@gmail.com")
#+end_src
n* Emacs internals optimizations
:PROPERTIES:
  :header-args: :tangle no
  :END:
I moved all of the code of this part to =early-init.el=.
** GC
Emacs is a really old software, many of the default values in Emacs aren't actually suited for today's
modern computers. Emacs has a built-in Garbage collector that does garbage collection every time Emacs lisp
VM reaches a threshold of memory usage, and this garbage collector sweeps are sometimes annoying, but remember 
garbage collector threshold is a tricky setting, if you set it to low you will start experiencing a lot of GC sweeps that slow you down
and if you set it very high GC sweeps take forever to finish. Default Emacs =gc-cons-threshold= is set to =800000=
which is not really enough specially for Emacs startup since it needs to scan through all your installed packages
so we are going to increase it during startup time and then after Emacs initialization we can decrease it again.
#+begin_src emacs-lisp
  (message "$$$$$$$$$$$$$$$$ should be disabled")
  (setq gc-cons-threshold (* 1024 1024 100)) ;; 100MB for Emacs initialization process
  (add-hook 'after-init-hook (lambda ()
                               (setq gc-cons-threshold (* 1024 1024 20)))) ;; reseting the gc cons to 20MB
#+end_src
** file-name-handler-alist
Emacs has a global variable called =file-name-handler-alist=, it stores handlers for various file extensions, before =use-package= era we used to
add new file extensions to this variable to load their respective handler, On every file open, Emacs looks and scans through this variable to see if it
can find a match for given file, but during the startup process we are going to only evaluate stuff so we don't need file-handlers, as result we are going 
to set this file's value to a nil value during startup and restore it's original value after emacs initialization.
#+begin_src emacs-lisp
  (defvar file-name-handler-alist-bak file-name-handler-alist "file name handler backup.")
  (setq file-name-handler-alist nil)
  (add-hook 'after-init-hook (lambda () (setq file-name-handler-alist file-name-handler-alist-bak)))
#+end_src
* Debug When necessary
#+begin_src emacs-lisp
;; (setq debug-on-error)
#+end_src
* Package manager setup
#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
(straight-use-package 'use-package)
#+end_src
* About this configuration
** Disabled packages
I actually don't use a lot of setup that I have in this configuration,
all the unused parts are disabled using =:disabled= in use-package declaration.
** Keybinding conventions
I respect Emacs keybinding conventions in my configuration with a few ideas borrowed from spacemacs.
+ All keybindings should be prefixed with =C-c= and then a single letter to avoid conflict with major modes keybindings.
+ Window related functionality like eyebrowse workspaces prefix with =w=
+ Major mode / language specific functions bind with prefix =m=
+ Operating System integration keys should be prefixed with =o=
+ Devops related stuff prefixed with =d=.
* Chapters
** Keybinding helper packages
#+begin_src emacs-lisp
  (use-package which-key
    :straight t
    :config
    (setq which-key-idle-delay 0.2)
    (which-key-add-key-based-replacements "C-c m" "Major mode functions")
    (which-key-add-key-based-replacements "C-c w" "workspace functionality")
    (which-key-add-key-based-replacements "C-c o" "external tools integration")
    (which-key-add-key-based-replacements "C-c e" "Editor functions")
    (which-key-add-key-based-replacements "C-c d" "Devops related functions")
    (which-key-mode 1)
    (which-key-setup-minibuffer))
  (use-package hydra :straight t)
  (use-package pretty-hydra :straight t)
#+end_src
For keybinding helpers I use two packages
+ =Which-key= when ever a key is pressed tell us what other options we have.
+ =Hydra= It's hard to explain exactly what hydra does, It creates interactive
keybindings like the ones in magit forexample but with more features.
[["https://www.youtube.com/watch?v=ONHEDj3kWrE&t=1258s"][Hydra Demo]]

** UI
*** Themes
  Now that we have use-package we can start installing thems, packages, etc. Let's start by installing some thems.
  for some time now I am using modus themes by the amazing =Protesilaos Stavrou= (btw check his youtube channel) which are simple but elegant themes
  but if you want a more modern look like =VSCode= or =Atom= you can use =doom-themes= as well.
  ([[https://github.com/hlissner/emacs-doom-themes/tree/screenshots][Doom Themes Screenshots]])
  #+BEGIN_SRC emacs-lisp
    (use-package modus-operandi-theme :straight t :defer t)
    (use-package modus-vivendi-theme :straight t :defer t)
    (use-package spacemacs-theme :straight t :defer t)
    (use-package doom-themes :straight t :defer t)
    (use-package badwolf-theme :straight t :defer t)
    (use-package monochrome-theme :straight t :defer t)
    (use-package purple-haze-theme :straight t :defer t)
    (use-package darkburn-theme :straight t :defer t)
    (use-package zenburn-theme :straight t :defer t)
  #+END_SRC
  You probably notice the =:defer= part in use-package, with =:defer= keyword (:something is called a keyword in elisp)
  use-package knows that we don't need this package to be loaded in startup, since we actually don't need all of our themes
  to be loaded at startup. Another keyword that you see is =:straight= that is telling use-package to make certain
  that this package is installed, and if it's not install it from elpa repo.
  Now let's set a theme
  #+BEGIN_SRC emacs-lisp
           (use-package emacs 
             :config 
             (setq ring-bell-function t)
             (setq visible-bell t))

           (use-package custom
             :demand
             :bind (("<f12>" . amirreza/toggle-color-mode))
             :config
             (defvar amirreza/current-mode 'dark "Current color of Emacs.")
             (defvar amirreza/dark-theme 'modus-vivendi)
             (defvar amirreza/light-theme 'doom-one-light)

             (defmacro amirreza/--load-theme (&rest theme-opts)
               `(progn (mapc #'disable-theme custom-enabled-themes)
                       (load-theme ,@theme-opts)))

             (defun amirreza/load-theme (theme)
               (interactive "sEnter Theme: ")
               (amirreza/--load-theme (intern theme) t))
             (defun amirreza/apply-color (mode)
               "Apply current color mode to Emacs."
               (if (eq amirreza/current-mode 'dark)
                   (amirreza/--load-theme amirreza/dark-theme t)
                 (amirreza/--load-theme  amirreza/light-theme t)))

             (defun amirreza/toggle-color-mode ()
               "Toggle current mode to the opposite"
               (interactive)
               (if (eq amirreza/current-mode 'dark)
                   (setq amirreza/current-mode 'light)
                 (setq amirreza/current-mode 'dark))
               (amirreza/apply-color amirreza/current-mode))
            (amirreza/apply-color amirreza/current-mode))
  #+END_SRC
***** Performance Tip 
 About 95% of packages we use don't need to be loaded at startup and =:defer= is only one of the multiple
 ways of lazy-loading in use-package we will see others later on.
*** Some cursor tweaks
 #+BEGIN_SRC emacs-lisp
    (use-package emacs
      :config
      (setq-default cursor-type 'box))

    (use-package frame
      :config
      (blink-cursor-mode -1))
    (use-package hl-line
      :config
      (global-hl-line-mode +1))

  #+END_SRC
*** Font
  To use specific font in Emacs you just need to call a function, that's easy ha ??
  #+BEGIN_SRC emacs-lisp
    (defvar amirreza/font "Hack-10")
    (set-face-attribute 'default t :font amirreza/font)
    (set-frame-font amirreza/font nil t)
    (global-prettify-symbols-mode 1)
  #+END_SRC
  If you evaluate code above you see the font changes.
  Now let's write some elisp, let's say that we want to have a function that we can call and change 
  our font interactively, let's write it.
  #+BEGIN_SRC emacs-lisp
    (defun hitchhiker/change-font (font size)
      (interactive "sFont: \nnSize: ")
      (set-face-attribute 'default t :font (format "%s-%d" font size))
      (set-frame-font (format "%s-%d" font size) nil t))
  #+END_SRC
  I'm not gonna discuss this function line by line, I'm only going to discuss calling it for now,
  for calling this function we have two ways, calling it from the code, or calling it interactively
  but how ? Emacs has a default keychord called M-x (execute-extended-command) that calls a interactive
  function interactively, many packages has these kind of functions for example load-theme that we used
  before is interactive as well, if we call it we will prompted to enter the font first and then the size
  and volla :).

*** Icons
 Emacs by default has no icons anywhere, but if you like icons forexample in the file browser
 you need to install a package for that. For icons we are going to use =all-the-icons= package which
 is a gourges icon package for emacs.
 #+BEGIN_SRC emacs-lisp :eval no
   (use-package all-the-icons

     :straight t
     :commands (all-the-icons-octicon
            all-the-icons-faicon
            all-the-icons-fileicon
            all-the-icons-wicon
            all-the-icons-material
            all-the-icons-alltheicon))

   (use-package all-the-icons-dired

     :straight t
     :init
     (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
 #+END_SRC
 =:commands= in use-package defers the loading of the package until on of listed commands (interactive functions)
 is called, basically first buffer that wants to use that it will get loaded. =:init= means when emacs started 
 no matter what are the other options evaluate the forms after =:init=.
*** Modeline
 #+begin_src emacs-lisp
   (use-package emacs 
     :config
     (setq amirreza/modeline-seperator "   ")
     (setq-default mode-line-format (list
                                     mode-line-front-space
                                     mode-line-misc-info ;; eyebrowse workspace number
                                     amirreza/modeline-seperator
                                     mode-line-modified
                                     amirreza/modeline-seperator
                                     "%m"
                                     amirreza/modeline-seperator
                                     "%b"
                                     amirreza/modeline-seperator
 ;;                                    mode-line-modes
 ;;                                  amirreza/modeline-seperator
                                     mode-line-position
                                     amirreza/modeline-seperator
                                     '(:eval vc-mode)
                                     mode-line-end-spaces
                                     )))
 #+end_src
** Windows/Workspaces
*** Window rules
Emacs windows can be configured in the matter of where their gonna open.
#+BEGIN_SRC emacs-lisp
    (setq display-buffer-alist
          '(("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Messages\\)\\*"
               (display-buffer-in-side-window)
               (window-width . 0.40)
               (side . right)
               (slot . 0))
            ("^vterm"
              (display-buffer-in-side-window)
              (window-width . 0.40)
              (side . right)
              (slot . 0)
              )
            ("\\*rg"
              (display-buffer-in-side-window)
              (window-width . 0.40)
              (side . right)
              (slot . 0))))
#+END_SRC
*** Eyebrowse
=Eyebrowse= gives you =i3= like experience in Emacs, let's you have multiple workspaces and switch between them.
#+BEGIN_SRC emacs-lisp
      (use-package eyebrowse :straight t
        :commands (eyebrowse-close-window-config
                   eyebrowse-create-window-config
                   eyebrowse-switch-to-window-config-0
                   eyebrowse-switch-to-window-config-1
                   eyebrowse-switch-to-window-config-2
                   eyebrowse-switch-to-window-config-3
                   eyebrowse-switch-to-window-config-4
                   eyebrowse-switch-to-window-config-5
                   eyebrowse-switch-to-window-config-6
                   eyebrowse-switch-to-window-config-7
                   eyebrowse-switch-to-window-config-8
                   eyebrowse-switch-to-window-config-9)

        :config (eyebrowse-mode +1)
        (pretty-hydra-define eyebrowse-hydra (:hint nil :exit t)
          ("Workspaces"
            (("0" eyebrowse-switch-to-window-config-0)
            ("1" eyebrowse-switch-to-window-config-1)
            ("2" eyebrowse-switch-to-window-config-2)
            ("3" eyebrowse-switch-to-window-config-3)
            ("4" eyebrowse-switch-to-window-config-4)
            ("5" eyebrowse-switch-to-window-config-5)
            ("6" eyebrowse-switch-to-window-config-6)
            ("7" eyebrowse-switch-to-window-config-7)
            ("8" eyebrowse-switch-to-window-config-8)
            ("9" eyebrowse-switch-to-window-config-9))
        
           "Actions"
            (("d" eyebrowse-close-window-config)
            ("c" eyebrowse-create-window-config)
            ("e" keyboard-quit))))
    
        :bind ("C-c w" . eyebrowse-hydra/body))

#+END_SRC
*** Winner (Restore Window layout)
When we are working with multiple windows open but we might maximize one window to focus
on it, but when we are done with focus mode ;) we need that layout back that's were winner mode
comes handy you can restore last window layout with just a function called =winner-undo= that
by default is bound to =C-c <left>=.
#+BEGIN_SRC emacs-lisp
  (use-package winner 
    :commands (winner-redo winner-undo))
#+END_SRC
*** Ace Window (Better Window Management)
#+BEGIN_SRC emacs-lisp
      (use-package ace-window
        :straight t
        :commands (ace-window)
        :bind (("C-x o" . 'ace-window)
               ("C-x C-o" . 'ace-window)))
#+END_SRC
*** Beacon
#+begin_src emacs-lisp
  (use-package beacon
    :straight t
    :defer 1
    :config (beacon-mode 1))
#+end_src
** Minibuffer completion
#+begin_src emacs-lisp
            ;; orderless completion style, we can divide our search string into space seperated parts
            (use-package orderless
              :straight t
              :config
              (setq completion-styles '(orderless)))

            (use-package icomplete
              :demand
              :bind
              (:map icomplete-minibuffer-map
                    ("C-n" . icomplete-forward-completions)
                    ("C-p" . icomplete-backward-completions)
                    ("C-f" . icomplete-forward-completions)
                    ("C-b" . icomplete-backward-completions)
                    ("<right>" . icomplete-forward-completions)
                    ("<left>" . icomplete-backward-completions)
                    ("<down>" . icomplete-forward-completions)
                    ("<up>" . icomplete-backward-completions)
                    ("<RET>" . icomplete-force-complete-and-exit)
                    ("<tab>" . icomplete-force-complete))

              :config
              (setq icomplete-max-delay-chars 2
                    icomplete-show-matches-on-no-input t
                    icomplete-hide-common-prefix nil)
              (when (> emacs-major-version 26)
                (fido-mode -1))
              (icomplete-mode 1))

            (use-package icomplete-vertical
              :straight t
              :demand
              :bind
              (:map icomplete-minibuffer-map
                     ("C-v" . icomplete-vertical-toggle))
              :config
              (icomplete-vertical-mode -1))
#+end_src
** Editor
*** Defaults
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (setq-default
     indent-tabs-mode nil
     tab-width 4) ;; emacs tabs settings

    (setq backup-directory-alist
          '(("." . "~/.emacs.d/backup/"))) ;; put all emacs backup files in oneplace
    (setq backup-by-copying t)
    (setq version-control t)
    (setq delete-old-versions t)
    (setq kept-new-versions 6)
    (setq kept-old-versions 2)
    (setq create-lockfiles nil)

    (defalias 'yes-or-no-p 'y-or-n-p) ;; answer with y-n instead of yes-no

    (setq echo-keystrokes 0.1) ;; echo keystrokes in minibuffer faster

    (setq use-dialog-box nil) ;; ask quesions in minibuffer
    (setq inhibit-splash-screen 0) ;; disable startup screen
    (setq ring-bell-function 'ignore) ;; don't make a sound

    (set-terminal-coding-system 'utf-8) ;; default emacs encodings
    (set-keyboard-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
    (setq-default fill-column 80) ;; column number which emacs start to line wrap.

                                          ; vertical scrolling
    (setq scroll-step 1)
    (setq scroll-margin 1)
    (setq scroll-conservatively 101)
    (setq scroll-up-aggressively 0.01)
    (setq scroll-down-aggressively 0.01)
    (setq auto-window-vscroll nil)
    (setq fast-but-imprecise-scrolling nil)
    (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
    (setq mouse-wheel-progressive-speed nil)
    ;; Horizontal Scroll
    (setq hscroll-step 1)
    (setq hscroll-margin 1))

  (use-package cus-edit
    :config
    (setq custom-file "~/.emacs.d/custom.el"))

  (use-package delsel ;; delete region when start typing
    :hook (after-init . delete-selection-mode))

  (use-package simple
    :config
    (column-number-mode +1)
    (setq kill-ring-max 15))

  (use-package display-line-numbers
    :config
    (global-display-line-numbers-mode +1))

  (use-package paren 
    :config
    (show-paren-mode 1)
    (setq show-paren-delay 0))

#+end_src
*** Custom motions
#+begin_src emacs-lisp
  (global-set-key (kbd "M-n") (lambda () (interactive) (next-line 10)))
  (global-set-key (kbd "M-p") (lambda () (interactive) (previous-line 10)))
#+end_src
*** Isearch
Isearch is emacs internal package for searching in buffers, I actually don't use it 
very often since I'm using swiper but I configured it so let it be here any way.
#+begin_src emacs-lisp
    (use-package isearch
      :config
      (setq isearch-highlight t)
      (setq isearch-whitespace-regexp ".*?")
      (setq isearch-lax-whitespace t)
      (setq isearch-regexp-lax-whitespace nil)
      (setq isearch-lazy-highlight t)
      :commands 
      (isearch-forward-regexp
       isearch-backward-regexp
       isearch-forward
       isearch-backward))

#+end_src
*** Fuzzy file finder 
Fuzzy file search is amazing tool that doesn't choke up even in my home folder 
it's just magic.
#+begin_src emacs-lisp
    (use-package fzf
      :straight (:repo "amirrezaask/fzf.el")
      :bind (("C-c f f" . fzf)
             ("C-c f d" . fzf-directory))
      :commands (fzf fzf-directory))
#+end_src
*** Ripgrep
Ripgrep is another magical tool that replaces the old =grep= command and actually
it's just amazing tool
#+begin_src emacs-lisp
    (use-package rg
     :straight t
     :commands (rg))
#+end_src
*** Dumb Jump
Dumb jump is actually a smart way of jumping to defenitions using grep tools like
=ag= or =rg=.
#+begin_src emacs-lisp
  (use-package dumb-jump
    :straight t
    :commands
    (dumb-jump-go
     dumb-jump-back)
    :config
    (setq dumb-jump-selector 'ivy)
    (dumb-jump-mode 1))
#+end_src
*** Org mode
**** Org
#+BEGIN_SRC emacs-lisp
    (use-package org
    :demand
    :init
    (defun amirreza/--org-insert-elisp-code-block ()
      (interactive)
      (insert (format "#+begin_src emacs-lisp\n\n#+end_src"))
      (previous-line)
      (beginning-of-line))
    :bind (:map org-mode-map
                ("C-c c b" . amirreza/--org-insert-elisp-code-block))
    :config
    (setq org-ellipsis "⤵")
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-support-shift-select t)
    (setq org-src-window-setup 'current-window)
    (setq org-agenda-files '("~/org/work.org" "~/org/personal.org")))
#+END_SRC
**** Org bullets
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :straight t
  :hook (org-mode . org-bullets-mode))
#+END_SRC
**** Org TOC
#+begin_src emacs-lisp
(use-package toc-org :straight t :hook (org-mode . toc-org-mode))
#+end_src
**** htmlize
#+begin_src emacs-lisp
(use-package htmlize :straight t :defer t)
#+end_src
*** Highlight indentation
#+begin_src emacs-lisp
 (use-package highlight-indent-guides
   :straight t
   :hook ((yaml-mode) . highlight-indent-guides-mode)
   :init
   (setq highlight-indent-guides-method 'character)
   :config
   (add-hook 'focus-in-hook #'highlight-indent-guides-auto-set-faces))
#+end_src
*** Sudo edit
#+begin_src emacs-lisp
   (use-package sudo-edit
        :straight t
        :commands (sudo-edit))
#+end_src
*** Expand region
#+begin_src emacs-lisp
   (use-package expand-region
     :straight t
     :bind (("C-=" . 'er/expand-region)
	    ("C--" . 'er/contract-region)))
#+end_src
*** Highlight TODO/FIXME/...
#+begin_src emacs-lisp
 (use-package hl-todo
   :straight t
   :hook ((prog-mode) . hl-todo-mode)
   :config
   (setq hl-todo-highlight-punctuation ":"
	 hl-todo-keyword-faces
	 `(("TODO"       warning bold)
	   ("FIXME"      error bold)
	   ("HACK"       font-lock-constant-face bold)
	   ("REVIEW"     font-lock-keyword-face bold)
	   ("NOTE"       success bold)
	   ("DEPRECATED" font-lock-doc-face bold))))
#+end_src
*** Multiple cursors
#+begin_src emacs-lisp
  (use-package multiple-cursors
    :straight t
    :commands (mc/edit-lines
      mc/mark-all-like-this
      mc/mark-next-like-this
      mc/skip-to-next-like-this
      mc/unmark-next-like-this
      mc/mark-previous-like-this
      mc/skip-to-previous-like-this
      mc/unmark-previous-like-this
      mc/mark-all-in-region-regexp
      mc/insert-numbers
      mc/insert-letters)
    :bind ("C->" .  amirreza-editor-mc-hydra/body)
    :config
    (pretty-hydra-define amirreza-editor-mc-hydra (:hint nil)
      ("Put cursor on"
       (("n" mc/mark-next-like-this "Mark next like this")
        ("p" mc/mark-previous-like-this "Mark next like this")
        ("a" mc/mark-all-like-this "Mark next like this")))))

#+end_src
*** IBuffer
#+begin_src emacs-lisp
  (use-package ibuffer
    :bind (("C-x C-b" . 'ibuffer)))
  (use-package ibuffer-projectile 
    :straight t
    :hook (ibuffer . ibuffer-projectile-set-filter-groups))

#+end_src
*** Iedit
#+begin_src emacs-lisp
  (use-package iedit
       :straight t
       :commands iedit-mode)
#+end_src
*** Vlf (very large file)
#+begin_src emacs-lisp
(use-package vlf :straight t :defer t)
#+end_src
*** Abbrevs/Skeleton
Every human being has limited number of keystrokes left, so let's make every one of them count.
Abbrev mode is Emacs internal that expands on defined abbrevations,
Abbrev mode is really helpful but in more complicated scenarios we need more smart tool,
so we use skeleton mode and we combine that with abbrev mode to get maximum power, we are 
going to define our skeletons in their respective languages. Snippet macro defines a new snippet,
Snippets are basically combination of abbrevs and skeletons, abbrevs are used for triggering
skeleton and skeleton does it's job of inserting text.
#+begin_src emacs-lisp
          (use-package abbrev :demand)
          (use-package skeleton :demand
            :config
            (defmacro amirreza/defsnippet (mode abbrv &rest skeleton-expansions)
              "Snippets are wrapper around skeleton and abbrevs."
              (let ((command-name (intern (format "amirreza/snippet-%s-%s" mode abbrv))))
                `(progn
                   (define-skeleton ,command-name ""
                     ,@skeleton-expansions)
                   (define-abbrev local-abbrev-table ,abbrv "" (quote ,command-name))))))
#+end_src

*** Rainbow delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters :straight t :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

*** Avy
#+begin_src emacs-lisp
    (use-package avy :straight t
      :commands (avy-goto-char avy-goto-char-2 avy-goto-lineavy-goto-word-1))
#+end_src
*** Edit configuration
#+begin_src emacs-lisp
    (defun amirreza/edit-configuration ()
       (interactive)
       (find-file "~/.emacs.d/README.org"))
#+end_src
*** Editor Hydra
#+begin_src emacs-lisp
  (pretty-hydra-define amirreza-editor-git-hydra (:hint nil :exit t)
    ("Actions"
     (("g" magit "Magit")
      ("m" git-messenger:popup-message "Git messanger"))))

  (pretty-hydra-define amirreza-editor-avy (:hint nil :exit t)
    ("Jump to"
     (("l" avy-goto-line "Avy jump to line")
      ("w" avy-goto-word-1 "Avy jump to word")
      ("cc" avy-goto-char-2 "Avy jump to characters")
      ("c" avy-goto-char "Avy jump to character"))))

  (pretty-hydra-define amirreza-editor-hydra (:hint nil :exit t)
    ("Actions"
     (("f" fzf "Fuzzy file search")
      ("e" amirreza/edit-configuration "Edit Emacs configuration file")
      ("g" amirreza-editor-git-hydra/body "Git actions")
      ("i" iedit "IEdit")
      ("r" rg "Ripgrep")
      ("m" amirreza-editor-mc-hydra/body "Multi cursors")
      ("a" amirreza-editor-avy/body "Avy")
      ("s" sudo-edit "Sudo edit"))))

   (global-set-key (kbd "C-c e") 'amirreza-editor-hydra/body)
#+end_src
** IDE setup
*** Add executable paths
#+begin_src emacs-lisp
  (use-package exec-path-from-shell 
    :straight t 
    :defer 1
    :config 
    (setq exec-path-from-shell-shell-name "sh")
    (exec-path-from-shell-initialize))
#+end_src
*** Code completion
Code completion consists of two parts, A source/server that provides the completions and 
an engine that knows when to open prompt and show the completions. We will configure servers later
but now we need to install the engine that shows us the completion.
=Company-mode= in my opinion is the best one out there, it consists of =backends= and =frontends=
backends connect to multiple tools that provide the completions and frontends are about the GUI.
Since we are going to use LSP as the main source for the completions we just need the default 
configuration of company.
For company backends we are going to use =company-capf= which is abbrv for =company complete at point function= which is a function in Emacs that major modes
can call an get completions based on that.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :demand
    :straight t
    :bind (:map company-active-map
                ("C-n" . company-select-next)
                ("C-p" . company-select-previous)
                ("C-o" . company-other-backend)
                ("<tab>" . company-complete-common-or-cycle)
                ("RET" . company-complete-selection))
    :config
    (setq company-minimum-prefix-lenght 1)
    (setq company-tooltip-limit 30)
    (setq company-idle-delay 0.0)
    (setq company-echo-delay 0.1)
    (setq company-backends '(company-capf company-dabbrev company-files company-dabbrev-code))
    (defmacro amirreza/with-backends (mode backends) 
      "Register a buffer local variable with given BACKENDS for given MODE. For registering backends for various modes use this"
      (let ((mode-hook (intern (concat (symbol-name mode) "-hook"))))
        (message "amirreza/with-backends called with %s %s %s" mode backends mode-hook)
        `(add-hook (quote ,mode-hook) (lambda ()
                                        (setq-local company-backends (quote ,backends))))))
    (global-company-mode t))

#+end_src
*** Language Server Protocol
Language Server protocol is a open source protocol developed by microsoft but now it's being
developed by community, it defines a communication protocol that a lanaguge server (let's say gopls)
can talk to various clients (let's say Emacs, Vi, VSCode) and provide several features such
as auto-complete or syntax linting.
#+BEGIN_SRC emacs-lisp
    (use-package lsp-mode 
      :straight t
      :commands (lsp lsp-deferred)
      :hook 
      ((python-mode
        go-mode) . lsp)
      :config
      (setq lsp-auto-guess-root t)
      :commands (lsp))

  (use-package dap-mode :straight t :defer t)
  (use-package lsp-ivy :straight t :commands (lsp-ivy-workspace-symbol))
  (use-package helm-lsp :disabled t :straight t :commands helm-lsp-workspace-symbol)

#+END_SRC
LSP-ui is a mode from the same author with the goal of configuring several Emacs packages to 
help ease developer experience when using LSP.
#+BEGIN_SRC emacs-lisp
  ;; (use-package lsp-ui :straight t :commands lsp-ui-mode :hook (lsp-mode . lsp-ui-mode))
#+END_SRC
*** Git integration
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :straight t
    :commands (magit-status)
    :bind
    (("C-x g" . 'magit-status)))

  (use-package diff-hl
    :straight t
    :config (global-diff-hl-mode 1))

  (use-package
    gitconfig-mode
    :straight t
    :mode "/\\.gitconfig\\'")

  (use-package gitignore-mode
    :straight t
    :mode "/\\.gitignore\\'")

  (use-package gitattributes-mode
    :straight t
    :mode "/\\.gitattributes\\'")

  (use-package git-messenger
    :straight t
    :commands
    (git-messenger:popup-message)
    :config
    (setq git-messenger:show-detail t)
    (setq git-messenger:use-magit-popup t))
#+END_SRC
*** Syntax checking
Emacs comes with a built in syntax checker called =flymake=, but since emacs community favors =flycheck= over =flymake= we are going to setup flycheck.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :straight t
    :hook (prog-mode . flycheck-mode))
#+END_SRC
*** Debugger Support
TBA
*** Docs
#+begin_src emacs-lisp
  (use-package eldoc
    :hook (prog-mode . eldoc-mode))
#+end_src
*** Programming languages
**** Python
***** Python Mode
  Emacs itself comes with =python-mode= which is python major mode that provides emacs with 
  syntax highlighting and some other features on python, so we just need to configure it the way 
  we want. I added some custom python functions to suit my python needs like the docstring function
  that inserts a docstring in python syntax.
  #+BEGIN_SRC emacs-lisp
    (use-package python-mode
      :mode "\\.py\\'"
      :config
      (defun amirreza/python-insert-docstring ()
        (interactive)
        (insert "'''\n'''")
        (previous-line))
      :bind
      (:map python-mode-map 
        ("C-c m d" . amirreza/python-insert-docstring)))
  #+END_SRC
***** Microsoft Language Server
  #+begin_src emacs-lisp
  (use-package lsp-python-ms :straight t :after python-mode)
  #+end_src
***** Pipenv
  =Pipenv= is now the de facto tool for python programmers to manage their project deps, so it's nice
  to have a wrapper for it in Emacs.
  #+BEGIN_SRC emacs-lisp
    (use-package pipenv
	         :straight t
	         :after python-mode)
  #+END_SRC
***** Py-autopep8
  We are using LSP for all our IDE like features but right now python lanugage server does not
  provide formmatting feature for python so we need to use another package called =py-autopep8= which
  actually is just a wrapper around python package that you need to install from =pypi= called 
  no suprises =py-autopep8=. We install this package and we need this package to hook it's format 
  function to =before-save-hook= of emacs, luckily this package provides a helper function to do that.
  #+BEGIN_SRC emacs-lisp
  (use-package py-autopep8
    :straight t
    :hook python-mode
    :config
    (py-autopep8-enable-on-save))

  #+END_SRC
**** Go
***** Go-mode
  Golang by default is not supported in Emacs, but don't fear, we can fix that by simply installing
  =go-mode= which is a major mode and it provides the basic syntax highlighting that we need, we also
  need to configure this package to enable some LSP features that are necessary like formatting. For
  go to work perfectly you need to add the =GOPATH= to your =exec-path= to let emacs find go binaries
  that it needs.
  #+BEGIN_SRC emacs-lisp
    (use-package go-mode
      :straight t
      :mode ("\\.go\\'" . go-mode)
      :init
      (add-hook 'go-mode-hook 'amirreza/go-hook)
      :config
      (defun amirreza/go-hook ()
        (interactive)
        ;; custom snippets
        (amirreza/defsnippet "go" "fmain" "" "func main() {" \n "}")
        (amirreza/defsnippet "go" "pkgm" "Package: " "package " str \n)
        (amirreza/defsnippet "go" "pl" "" "fmt.Println(\"" _ "\")") ;; _ is the cursor position after the expansion
        (amirreza/defsnippet "go" "pf" "" "fmt.Printf(\"" _ "\")")
        (amirreza/defsnippet "go" "ifer" "" "if err != nil {" \n _ \n "}")
        (amirreza/defsnippet "go" "if" "" "if " _ "{" \n "}")
        (amirreza/defsnippet "go" "for" "" "for " _ " := range {" \n \n "}")
        (amirreza/defsnippet "go" "fn" "" "func " _ "() {" \n \n "}")
        (amirreza/defsnippet "go" "tf" "" "func " _ "(t *testing.T) {" \n \n "}")
        (amirreza/defsnippet "go" "hh" "" "func " _ "(w http.ResponseWriter, r *http.Request) {" \n \n "}")

        (pretty-hydra-define amirreza-go-generator-hydra (:hint nil :exit t)
          ("Code blocks"
           (("t" amirreza/snippet-go-tf "test function")
            ("hh" amirreza/snippet-go-hh "http handler")
            ("f" amirreza/snippet-go-for "For loop")
            ("i" amirreza/snippet-go-if "If")
            ("pl" amirreza/snippet-go-pl "fmt.println")
            ("pf" amirreza/snippet-go-pf "fmt.printf"))))

        (define-key go-mode-map (kbd "<f5> r")
          (lambda () (interactive)
            (start-process "GoRun" "*GoRun*" "go" "run" (format "%s" buffer-file-name))))

        (define-key go-mode-map (kbd "C-c m g") 'amirreza-go-generator-hydra/body)
        ;; add go binaries to exec-path
        (add-to-list 'exec-path (concat (getenv "HOME") "/go/bin"))

        ;; show lambdas instead of funcs
        (setq-local prettify-symbols-alist '(("func" . 955)))
        (add-hook 'before-save-hook 'lsp-format-buffer t t)
        (add-hook 'before-save-hook 'lsp-organize-imports t t)))

  #+END_SRC
***** Go-add-tags
  it's always a pain to manually add struct tags for a struct specially when
  the struct has so many fields, again thanks to the emacs community we have package for that 
  to ease that task for us.
  #+BEGIN_SRC emacs-lisp
    (use-package go-add-tags :straight t :bind (:map go-mode-map ("C-c m s t" . go-add-tags)))
  #+END_SRC
***** Go-test
  =VSCode= has a great support when it comes to running go tests, it gives you the ability to 
  run a test when you are editing or viewing it but it does'nt mean that Emacs can't do that.
  #+BEGIN_SRC emacs-lisp
    (use-package gotest :straight t 
      :bind
      (:map go-mode-map 
            ("C-c m t f" . go-test-current-file)
            ("C-c m t t" . go-test-current-test)))
  #+END_SRC
**** Scheme
  I use guile as my scheme compiler.
  #+begin_src emacs-lisp
    (use-package scheme
    :config
    (setq scheme-program-name "guile"))
  #+end_src
**** Zig
  #+begin_src emacs-lisp
    (use-package zig-mode 
      :straight t
      :mode "\\.zig\\'")
  #+end_src
**** Emacs lisp
  Emacs lisp should be supported by default ha ? actually it has almost all support you need but 
  we can even go further.x
  #+BEGIN_SRC emacs-lisp
    (use-package elisp-mode
      :hook
      (emacs-lisp-mode-hook . amirreza/elisp-hook)
      :config
      (defun amirreza/elisp-hook ()
        (setq-local prettify-symbols-alist '(("fn" . 955)))
        (defun --amirreza/emacs-lisp-repeat (str count)
          "Create dashes with given COUNT."
          (let ((dashes ""))
            (dotimes (iterator count dashes)
              (setq dashes (concat dashes str)))))

        (defun --amirreza/emacs-lisp-wrap-text-in-spaces (text)
          (let* ((len (length text))
                 (spaces-length-side (/ (- 80 len) 2))
                 (spaces-side (--amirreza/emacs-lisp-repeat " " spaces-length-side)))
            (format "%s%s%s" spaces-side text spaces-side)))

        (defun amirreza/emacs-lisp-insert-comment-line (text)
          "Insert a comment line with given TEXT."
          (interactive "sComment: ")
          (let* ((text-wrapped (--amirreza/emacs-lisp-wrap-text-in-spaces text))
                 (dashes (--amirreza/emacs-lisp-repeat "=" 80))))
          (insert (format "\n;;%s\n;;%s\n;;%s" dashes text-wrapped dashes))))
      :bind
      (:map emacs-lisp-mode-map
            ("C-c m d" . 'amirreza/emacs-lisp-insert-comment-line)))
  #+END_SRC
**** Clojure
***** Clojure Mode
      #+BEGIN_SRC emacs-lisp
        (use-package clojure-mode :straight t
          :mode "\\.cljs?\\'"
          :config
          (setq-local prettify-symbols-alist '(("fn" . 955) ; λ
                                                ("->" . 8594))))
      #+END_SRC
***** Cider
  #+BEGIN_SRC emacs-lisp
    (use-package cider 
      :straight t
      :commands (cider cider-jack-in))
  #+END_SRC
**** Common Lisp
***** Common-lisp mode
  #+BEGIN_SRC emacs-lisp
  (use-package lisp-mode :mode "\\.cl\\'")
  #+END_SRC
***** Common Lisp Integrated Environment
  #+BEGIN_SRC emacs-lisp
  (use-package sly :straight t :mode "\\.cl\\'")
  #+END_SRC
**** Haskell
***** Haskell mode
  #+BEGIN_SRC emacs-lisp
  (use-package haskell-mode :straight t :mode "\\.hs\\'")
  #+END_SRC
***** Haskell IDE engine
  #+BEGIN_SRC emacs-lisp
  (use-package lsp-haskell :straight t :hook haskell-mode)
  #+END_SRC
**** HTML/CSS
  #+BEGIN_SRC emacs-lisp
    (use-package web-mode :straight t :mode ("\\.html\\'" "\\.css\\'"))
  #+END_SRC
**** PHP
***** PHP mode
  #+BEGIN_SRC emacs-lisp
  (use-package php-mode :straight t :mode "\\.php\\'")
  #+END_SRC
***** PHP Runtime Integration
  #+BEGIN_SRC emacs-lisp
  (use-package php-runtime :straight t :after php-mode)
  #+END_SRC
***** Composer Integration
  #+BEGIN_SRC emacs-lisp
    (use-package composer :straight t :after php-mode)
  #+END_SRC
***** PHPUnit
  #+BEGIN_SRC emacs-lisp
    (use-package phpunit :straight t
      :commands (php-current-test php-current-class php-current-project)
      :bind (:map php-mode-map 
                  ("C-c m t t" . php-current-test)
                  ("C-c m t c" . php-current-class)
                  ("C-c m t p" . php-current-project)))
  #+END_SRC
**** Rust
***** Rust mode
  #+BEGIN_SRC emacs-lisp
  (use-package rust-mode :straight t :mode "\\.rs\\'")
  #+END_SRC

** Integrated tools/functionality
*** File Manager
  #+begin_src emacs-lisp
      (use-package dired
        :config
        (add-hook 'dired-mode-hook (lambda () 
                                     (dired-hide-details-mode 1))))

      (use-package dired-sidebar :straight t
        :bind
        (("<f8>" . dired-sidebar-toggle-sidebar)))

      (use-package dired-subtree
        :straight t
        :bind (:map dired-mode-map
                    ("<tab>" . dired-subtree-toggle)))

      (use-package peep-dired
        :straight t
        :after dired
        :config
        (setq peep-dired-cleanup-on-disable t)
        (setq peep-dired-enable-on-directories nil)
        (setq peep-dired-ignored-extensions
              '("mkv" "webm" "mp4" "mp3" "ogg" "iso"))
        :bind (:map dired-mode-map
                    ("P" . peep-dired)))
  #+end_src

*** Mail & News reader
  Mail setup in Emacs using Gnus.
  #+begin_src emacs-lisp
    (use-package auth-source
      :after gnus
      :config
      (setq auth-sources '("~/.authinfo.gpg" "~/.authinfo")))

    (use-package gnus
      :commands (gnus)
      :config
      (setq gnus-thread-sort-functions
            '(gnus-thread-sort-by-number
              gnus-thread-sort-by-date))

      (setq gnus-select-method '(nnnil))
      (setq gnus-secondary-select-methods
       '((nnimap "Gmail"
                 (nnimap-address "imap.gmail.com")
                 (nnimap-server-port "imaps")
                 (nnimap-stream ssl)))))
  #+end_src

*** IRC
  #+begin_src emacs-lisp
    (use-package erc 
      :commands erc
      :config
      (setq erc-nick "amirrezaask")
      (setq erc-autojoin-channels-alist
            '(("freenode.net" "#emacs" "#5hit"))))
  #+end_src

*** Process management
  #+begin_src emacs-lisp
    (use-package proced
      :commands proced)
  #+end_src

*** Music
#+begin_src emacs-lisp
  (use-package rhythmbox
    :straight (:host github :repo "amirrezaask/Rhythmbox.el"))
#+end_src
*** IDE Hydra
#+begin_src emacs-lisp
  (pretty-hydra-define amirreza-os-hydra (:hint nil :exit t)
    ("Programs"
     (("r" Rhythmbox "Rhythmbox")
     ("p" proced "Process Manager"))))
  (global-set-key (kbd "C-c o") 'amirreza-os-hydra/body)
#+end_src
** Devops Tools
*** Some syntax highlights
#+begin_src emacs-lisp
  (use-package crontab-mode :defer t :straight t)
  (use-package apache-mode :straight t
    :mode ("\\.htaccess\\'" "httpd\\.conf\\'" "srm\\.conf\\'" "access\\.conf\\'"))
  (use-package systemd :straight t
    :mode ("\\.service\\'" "\\.timer\\'"))
  (use-package nginx-mode :straight 
    :mode ("/etc/nginx/conf.d/.*" "/etc/nginx/.*\\.conf\\'"))
#+end_src
*** TRAMP
#+begin_src emacs-lisp
    (use-package tramp
          :commands (tramp)
          :config
          (setq tramp-default-method "ssh"))
#+end_src
*** Docker
#+BEGIN_SRC emacs-lisp
      (use-package docker-compose-mode
        :straight t
        :mode "docker-compose\\.yml")

      (use-package docker :straight t 
        :bind
        ("C-c d d" . docker))

#+END_SRC
*** Kubernetes
#+begin_src emacs-lisp
(use-package kubel :straight t :commands (kubel) :bind (("C-c d k" . kubel)))
#+end_src

* Benchmark startup time
#+begin_src emacs-lisp
(defvar amirreza/startup-elapsed (- (float-time) amirreza/emacs-init-timestamp))
#+end_src
