#+TITLE: AmirrezaAsk Emacs
#+AUTHOR: amirrezaask
* Table Of contents                                                   :TOC@3:
- [[#personal-information][Personal information]]
- [[#startup-time][Startup Time]]
- [[#core][Core]]
  - [[#package-manager][Package manager]]
  - [[#module-system][Module System]]
  - [[#gcmh][GCMH]]
- [[#enabled-modules][Enabled Modules]]
- [[#basic-setup][Basic Setup]]
  - [[#tab-setting][Tab Setting]]
  - [[#backup-files-configuration][Backup files configuration]]
  - [[#y-or-n-instead-of-yes-or-no][y-or-n instead of yes-or-no]]
  - [[#show-keystrokes-in-minibuffer][Show keystrokes in minibuffer]]
  - [[#ask-questions-in-minibuffer][Ask questions in minibuffer]]
  - [[#disable-emacs-start-screen][Disable Emacs start screen]]
  - [[#always-remain-silent][Always remain silent]]
  - [[#default-encoding][Default encoding]]
  - [[#default-column-width][Default column width]]
  - [[#scrolling][Scrolling]]
  - [[#custom-file-reloaction][Custom file reloaction]]
  - [[#delete-selectionregion-when-start-typing][Delete selection/region when start typing]]
  - [[#show-column-number-in-modeline][Show column number in modeline]]
  - [[#capacity-of-kill-ring][Capacity of kill-ring]]
  - [[#show-laptop-battery-status-in-modeline][Show laptop battery status in modeline]]
  - [[#show-time-in-modeline][Show time in modeline]]
  - [[#show-line-numbers][Show line numbers]]
  - [[#highlight-matching-parens][Highlight matching parens]]
  - [[#track-laptop-battery][Track laptop battery]]
  - [[#startup-page][Startup page]]
  - [[#helper-macros][Helper Macros]]
- [[#emacs-x-window-manager][Emacs X Window Manager]]
- [[#keybindings][Keybindings]]
  - [[#evil][Evil]]
  - [[#which-key][Which-key]]
- [[#appereance][Appereance]]
  - [[#themes][Themes]]
  - [[#cursor][Cursor]]
  - [[#modeline][Modeline]]
  - [[#font][Font]]
  - [[#tabline][Tabline]]
  - [[#dashboard][Dashboard]]
- [[#completion-framework][Completion Framework]]
  - [[#ivy][Ivy]]
  - [[#selectrum][Selectrum]]
- [[#project-integration][Project Integration]]
- [[#searching][Searching]]
  - [[#smarter-file-search-and-greping][Smarter file search and greping]]
  - [[#in-buffer-searching][In buffer searching]]
  - [[#ripgrep-with-persitent-result][Ripgrep with persitent result]]
  - [[#smart-symbol-and-file-finding][Smart symbol and file finding]]
  - [[#file-type-search][File Type Search]]
- [[#emacs-buffers-and-windows][Emacs Buffers and Windows]]
  - [[#window-rules][Window rules]]
  - [[#eyebrowse][Eyebrowse]]
  - [[#winner-restore-window-layout][Winner (Restore Window layout)]]
  - [[#ace-window-better-window-management][Ace Window (Better Window Management)]]
  - [[#ibuffer][Ibuffer]]
- [[#vterm][VTerm]]
- [[#editing--writing][Editing & Writing]]
  - [[#editor-zoom-inout][Editor zoom in/out]]
  - [[#10-line-jump][10 Line Jump]]
  - [[#highlight-indentation][Highlight indentation]]
  - [[#sudo-edit][Sudo edit]]
  - [[#expand-region][Expand region]]
  - [[#highlight-todofixme][Highlight TODO/FIXME/...]]
  - [[#multiple-cursors][Multiple cursors]]
  - [[#dont-choke-on-large-data][Don't choke on large data]]
  - [[#tramp-edit-remote-files][Tramp: Edit remote files]]
  - [[#org][Org]]
    - [[#org-toc][Org TOC]]
    - [[#htmlize][htmlize]]
  - [[#outline-mode][Outline Mode]]
  - [[#markdown-mode][Markdown mode]]
  - [[#pdf-tools][Pdf tools]]
  - [[#misc-file-modes][Misc file modes]]
- [[#sync-env-from-default-shell][Sync ENV from default shell]]
- [[#development][Development]]
  - [[#auto-header][Auto Header]]
  - [[#code-completion][Code Completion]]
  - [[#movement-based-on-language-semantics][Movement based on language semantics]]
  - [[#snippets][Snippets]]
  - [[#dumb-jump][Dumb Jump]]
  - [[#lsp][LSP]]
    - [[#lsp-mode][LSP mode]]
    - [[#eglot][Eglot]]
  - [[#languages][Languages]]
    - [[#go][Go]]
    - [[#cc][C/C++]]
    - [[#java][Java]]
    - [[#python][Python]]
    - [[#scheme][Scheme]]
    - [[#lua][Lua]]
    - [[#zig][Zig]]
    - [[#lisp-configuration][Lisp configuration]]
    - [[#emacs-lisp][Emacs lisp]]
    - [[#clojure][Clojure]]
    - [[#common-lisp][Common Lisp]]
    - [[#haskell][Haskell]]
    - [[#htmlcss][HTML/CSS]]
    - [[#php][PHP]]
    - [[#rust][Rust]]
    - [[#protobuf][Protobuf]]
    - [[#nix][Nix]]
    - [[#terraform][Terraform]]
  - [[#debugger][Debugger]]
  - [[#rainbow-delimiters][Rainbow delimiters]]
  - [[#docs][Docs]]
  - [[#vcs][VCS]]
- [[#file-manager-dired][File Manager (Dired)]]
- [[#integrated-tools][Integrated Tools]]
  - [[#process-management][Process management]]
  - [[#rhythmbox][Rhythmbox]]
  - [[#video][Video]]
  - [[#docker][Docker]]
  - [[#kubernetes][Kubernetes]]
  - [[#application-laucnherdmenu][Application Laucnher(dmenu)]]
  - [[#terminal][Terminal]]
- [[#dotfiles][Dotfiles]]

* Personal information
#+begin_src emacs-lisp
    (setq user-full-name "AmirrezaAskarpour"
          user-mail-address "raskarpour@gmail.com")
#+end_src
* Startup Time
#+begin_src emacs-lisp
  (defun amirreza/startup-time ()
    (interactive)
    (message "Emacs start time: %.2f" (float-time (time-subtract after-init-time before-init-time))))
#+end_src
* Core
Core is a set of basic functionalities i need to build my emacs upon them.
** Package manager
My package manager is based on combining `Straight.el` and `use-package` together with some extra sugar on top.
** Module System
My module system is a way to enable/disable an elisp block using a central list of enabled modules.
** GCMH
Tune garbage collector to act smarter. ( credits to Andre for creating this library )
* Enabled Modules
#+begin_src emacs-lisp
(defvar amirreza/modules '(ivy doom/modeline dashboard))
#+end_src
* Basic Setup
** Tab Setting
#+begin_src emacs-lisp
  (pkg! emacs
    :config
    (setq-default indent-tabs-mode nil
                  tab-width 4))
#+end_src
** Backup files configuration
#+begin_src emacs-lisp
    (pkg! emacs 
      :config 
      (setq backup-by-copying t)
      (setq version-control t)
      (setq delete-old-versions t)
      (setq kept-new-versions 6)
      (setq kept-old-versions 2)
      (setq create-lockfiles nil)
      (setq backup-directory-alist
            '(("." . "~/.emacs.d/backup/"))))
#+end_src
** y-or-n instead of yes-or-no
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** Show keystrokes in minibuffer
#+begin_src emacs-lisp
(setq echo-keystrokes 0.1)
#+end_src
** Ask questions in minibuffer
#+begin_src emacs-lisp
(setq use-dialog-box nil)
#+end_src
** Disable Emacs start screen
#+begin_src emacs-lisp
(setq inhibit-splash-screen 0)
#+end_src
** Always remain silent
#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src
** Default encoding
#+begin_src emacs-lisp
(set-terminal-coding-system 'utf-8) ;; default emacs encodings
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+end_src
** Default column width
#+begin_src emacs-lisp
(setq-default fill-column 80) ;; column number which emacs start to line wrap.
#+end_src
** Scrolling
#+begin_src emacs-lisp
  (setq scroll-step 5)
  (setq scroll-margin 5)
  (setq scroll-conservatively 101)
  (setq scroll-up-aggressively 0.11)
  (setq scroll-down-aggressively 0.01)
  (setq auto-window-vscroll nil)
  (setq fast-but-imprecise-scrolling nil)
  (setq mouse-wheel-scroll-amount '(5
                                    ((shift) . 10)))
  (setq mouse-wheel-progressive-speed t)
  ;; Horizontal Scroll
  (setq hscroll-step 1)
  (setq hscroll-margin 1)
#+end_src
** Custom file reloaction
#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
#+end_src
** Delete selection/region when start typing
#+begin_src emacs-lisp
  (pkg! delsel ;; delete region when start typing
    :hook (after-init . delete-selection-mode))
#+end_src
** Show column number in modeline
#+begin_src emacs-lisp
(column-number-mode +1)
#+end_src
** Capacity of kill-ring
#+begin_src emacs-lisp
(setq kill-ring-max 15)
#+end_src
** Show laptop battery status in modeline
#+begin_src emacs-lisp
(pkg! battery :config (display-battery-mode 1))
#+end_src
** Show time in modeline
#+begin_src emacs-lisp
(pkg! time :config (display-time-mode 1))
#+end_src
** Show line numbers
#+begin_src emacs-lisp
(global-display-line-numbers-mode -1)
#+end_src
** Highlight matching parens
#+begin_src emacs-lisp
  (pkg! paren 
    :config
    (show-paren-mode 1)
    (setq show-paren-delay 0))
#+end_src
** Track laptop battery
#+begin_src emacs-lisp
  (pkg! battery
    :config (display-battery-mode 1))
#+end_src

** Startup page
I want my Emacs to open my TODO file on every startup and have a that buffer open and accessible with a short key.
#+begin_src emacs-lisp
  (defvar amirreza/todo-file "~/TODO.org" "Personal Todo file")
  (defun amirreza/open-todo ()
      (interactive)
      (find-file amirreza/todo-file))
  (global-set-key (kbd "<f2>") 'amirreza/open-todo)
#+end_src
** Helper Macros
#+begin_src emacs-lisp
  (defmacro amirreza/cmd! (&rest body)
    `(lambda (&rest _) (interactive) ,@body))
#+end_src
* Emacs X Window Manager
Emacs is so extensible that it can actually be a X window manager. You can literally login into Emacs, using exwm package you can run your whole computing environment inside Emacs.
#+begin_src emacs-lisp
(if-enabled? exwm
  (pkg! exwm
    :straight t
    :config
    (require 'exwm)
    (require 'exwm-config)
    (require 'exwm-systemtray)

    (defun amirreza/exwm-lock ()
      "lock using 'slock'"
      (interactive)
      (start-process "" nil "/usr/bin/slock"))

    (defun amirreza/application-launcher (command)
      "Acts as a dmenu replacement."
      (interactive (list (read-shell-command "$ ")))
      (start-process-shell-command command nil command))

    (defun amirreza/exwm-current-workspace ()
      "Show index of current workspace."
      (interactive)
      exwm-workspace-current-index)

    (setq exwm-workspace-number 10)
    (add-hook 'exwm-update-class-hook
              (lambda ()
                (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                            (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-class-name))))

    (add-hook 'exwm-update-title-hook
              (lambda ()
                (when (or (not exwm-instance-name)
                          (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-title))))
    (setq exwm-input-global-keys
          `(
            ;; Bind "s-r" to exit char-mode and fullscreen mode.
            ([?\s-r] . exwm-reset)
            ([?\s-g] . keyboard-quit)
            ;; Bind "s-w" to switch workspace interactively.
            ([?\s-w] . exwm-workspace-switch)

            ;; Bind "s-0" to "s-9" to switch to a workspace by its index.
            ,@(mapcar (lambda (i)
                        `(,(kbd (format "s-%d" i)) .
                          (lambda ()
                            (interactive)
                            (exwm-workspace-switch-create ,i))))
                      (number-sequence 0 9))
            ;; Bind "s-&" to launch applications ('M-&' also works if the output
            ;; buffer does not bother you).
            ([?\s-d] . amirreza/application-launcher)
            ;; Bind "s-l" to "slock", a simple X display locker.
            ([?\s-l] . amirreza/exwm-lock)
            (,(kbd "<XF86AudioRaiseVolume>") . (lambda ()
                                                             (interactive)
                                                             (start-process-shell-command "RaiseVolume" nil "pactl set-sink-volume @DEFAULT_SINK@ +10%")))

            (,(kbd "<XF86AudioLowerVolume>") . (lambda ()
                                                             (interactive)
                                                             (start-process-shell-command "DownVolume" nil "pactl set-sink-volume @DEFAULT_SINK@ -10%")))

            (,(kbd "<XF86AudioMute>") . (lambda ()
                                                      (interactive)
                                                      (start-process-shell-command "MuteVolume" nil "pactl set-sink-mute @DEFAULT_SINK@ toggle")))

            (,(kbd "<XF86AudioMicMute>") . (lambda ()
                                                         (interactive)
                                                         (start-process-shell-command "MuteMicVolume" nil "pactl set-source-mute @DEFAULT_SOURCE@ toggle")))


            ))


    (setq exwm-input-simulation-keys
          '(
            ;; movement
            ([?\C-b] . [left])
            ([?\M-b] . [C-left])
            ([?\C-f] . [right])
            ([?\M-f] . [C-right])
            ([?\C-p] . [up])
            ([?\C-n] . [down])
            ([?\C-a] . [home])
            ([?\C-e] . [end])
            ([?\M-v] . [prior])
            ([?\C-v] . [next])
            ([?\C-d] . [delete])
            ([?\C-k] . [S-end delete])
            ;; cut/paste.
            ([?\C-w] . [?\C-x])
            ([?\M-w] . [?\C-c])
            ([?\C-y] . [?\C-v])
            ;; search
            ([?\C-s] . [?\C-f])))


    (require 'exwm-randr)

    ;; (setq exwm-randr-workspace-output-plist '(0 "eDP-1"
    ;;                                             1 "HDMI-1"
    ;;                                             2 "HDMI-1"
    ;;                                             3 "HDMI-1"
    ;;                                             4 "HDMI-1"
    ;;                                             5 "HDMI-1"
    ;;                                             6 "eDP-1"
    ;;                                             7 "HDMI-1"
    ;;                                             8 "HDMI-1"
    ;;                                             9 "HDMI-1"))
    (add-hook 'exwm-randr-screen-change-hook
              (lambda ()
                (start-process-shell-command
                 "xrandr" nil "xrandr --output HDMI-1 --above eDP-1 --mode 1920x1080")))

    (global-set-key (kbd "<XF86AudioRaiseVolume>") (lambda ()
                                                   (interactive)
                                                   (start-process-shell-command "RaiseVolume" nil "pactl set-sink-volume @DEFAULT_SINK@ +10%")))

    (global-set-key (kbd "<XF86AudioLowerVolume>") (lambda ()
                                                   (interactive)
                                                   (start-process-shell-command "DownVolume" nil "pactl set-sink-volume @DEFAULT_SINK@ -10%")))

    (global-set-key (kbd "<XF86AudioMute>") (lambda ()
                                                   (interactive)
                                                   (start-process-shell-command "MuteVolume" nil "pactl set-sink-mute @DEFAULT_SINK@ toggle")))

    (global-set-key (kbd "<XF86AudioMicMute>") (lambda ()
                                                   (interactive)
                                                   (start-process-shell-command "MuteMicVolume" nil "pactl set-source-mute @DEFAULT_SOURCE@ toggle")))
    (exwm-randr-enable)
    (start-process-shell-command "Set keyboard layout" nil "setxkbmap -layout 'us,ir' -option 'grp:shifts_toggle' -option 'ctrl:nocaps'")
    (exwm-systemtray-enable)
    (exwm-enable)))
#+end_src
* Keybindings
** Evil
#+begin_src emacs-lisp
  (if-enabled? evil
            (pkg! evil
              :straight t
              :init
              (setq evil-want-keybinding nil)
              :bind
              (:map evil-normal-state-map
                    ("g c" . comment-line)
                    ("SPC SPC" . amirreza/file-finder)
                    ("SPC f f" . find-file)
                    ("SPC ." . counsel-M-x)
                    ("SPC h d f" . counsel-describe-function)
                    ("SPC h d v" . counsel-describe-variable)
                    ("SPC h d k" . describe-key))
              :config
              (evil-mode 1))

            (pkg! evil-escape :straight t :config (setq-default evil-escape-key-sequence "jk") (setq evil-escape-unordered-key-sequence t) (evil-escape-mode 1))
            (pkg! evil-collection :straight t :config (evil-collection-init))

            (pkg! evil-surround
              :straight t
              :config
              (global-evil-surround-mode 1))
            )
#+end_src
** Which-key
#+begin_src emacs-lisp
  (pkg! which-key
    :straight t
    :defer 1
    :init
    (setq which-key-sort-order #'which-key-prefix-then-key-order
            which-key-sort-uppercase-first nil
            which-key-add-column-padding 1
            which-key-max-display-columns nil
            which-key-min-display-lines 6
            which-key-side-window-slot -10)
    :config
    (setq which-key-idle-delay 0.3)
    (defalias 'which-key! 'which-key-add-key-based-replacements)
    (which-key-mode 1)
    (which-key-setup-minibuffer))
#+end_src
* Appereance
** Themes
 #+BEGIN_SRC emacs-lisp
   (pkg! modus-operandi-theme :straight t :defer t)
   (pkg! modus-vivendi-theme :straight t :defer t)
   (pkg! doom-themes :straight t :defer t)
 #+END_SRC
 You probably notice the =:defer= part in pkg!, with =:defer= keyword (:something is called a keyword in elisp)
 pkg! knows that we don't need this package to be loaded in startup, since we actually don't need all of our themes
 to be loaded at startup. Another keyword that you see is =:straight= that is telling pkg! to make certain
 that this package is installed, and if it's not install it from elpa repo.
 Now let's set a theme
 #+BEGIN_SRC emacs-lisp
   (pkg! emacs 
     :config 
     (setq ring-bell-function t)
     (setq visible-bell t))

   (pkg! custom
     :defer 1
     :bind (("<f12>" . amirreza/toggle-color-mode))
     :config
     (defvar amirreza/current-mode 'dark "Current color mode of Emacs.")
     (defvar amirreza/dark-theme 'doom-one)
     (defvar amirreza/light-theme 'modus-operandi)

     (defmacro amirreza/--load-theme (&rest theme-opts)
       `(progn (mapc #'disable-theme custom-enabled-themes)
               (load-theme ,@theme-opts)))

     (defun amirreza/load-theme ()
       (interactive)
       (let ((theme (intern  (completing-read "Theme: " (mapcar #'symbol-name
                                                                (custom-available-themes))))))

         (amirreza/--load-theme theme t)))

     (defun amirreza/apply-color (mode)
       "Apply current color mode to Emacs."
       (if (eq amirreza/current-mode 'dark)
           (amirreza/--load-theme amirreza/dark-theme t)
         (amirreza/--load-theme  amirreza/light-theme t)))

     (defun amirreza/toggle-color-mode ()
       "Toggle current mode to the opposite"
       (interactive)
       (if (eq amirreza/current-mode 'dark)
           (setq amirreza/current-mode 'light)
         (setq amirreza/current-mode 'dark))
       (amirreza/apply-color amirreza/current-mode))
    (amirreza/apply-color amirreza/current-mode))
 #+END_SRC
***** Performance Tip 
 About 95% of packages we use don't need to be loaded at startup and =:defer= is only one of the multiple
 ways of lazy-loading in pkg! we will see others later on.
** Cursor
 #+BEGIN_SRC emacs-lisp
   (pkg! emacs
     :config
     (setq-default ring-bell-function 'ignore)
     (setq-default cursor-type 'bar))

   (pkg! frame
     :config
     (blink-cursor-mode 1))

   (pkg! hl-line
     :defer 1
     :config
     (global-hl-line-mode +1))

  #+END_SRC
** Modeline
#+begin_src emacs-lisp
  (if-enabled? amirreza/modeline 
     (setq mode-line-percent-position '(-3 "%p"))

     (defface amirreza/buffer-face
       '(
         (((background dark))  :foreground "IndianRed1" :weight bold)
         (((background light)) :foreground "blue violet" :weight bold)
         )
       "Face for buffer name.")

     (defface amirreza/date-face
       '(
         (((background dark)) :foreground "yellow" :weight bold)
         (((background light)) :foreground "tomato" :weight bold)
         )
       "Face for global variables.")


     (defface amirreza/vcs-face
       '(
         (((background dark)) :foreground "cyan" :weight bold)
         (((background light)) :foreground "olive drab" :weight bold)
         )
       "Face for global variables.")

     (defface amirreza/mode-face
       '(
         (((background dark)) :foreground "spring green" :weight bold)
         (((background light)) :foreground "royal blue" :weight bold)
         )
       "Face for global variables.")

     (defface amirreza/pos-face
       '(
         (((background dark)) :foreground "light slate blue" :weight bold)
         (((background light)) :foreground "firebrick" :weight bold)
         )
       "Face for global variables.")

     (defface amirreza/workspace-face
       '(
         (((background dark)) :foreground "orange" :weight bold)
         (((background light)) :foreground "violet red" :weight bold)
         )
       "Face for global variables.")


     (setq display-time-string-forms
           '((propertize
              (concat 24-hours ":" minutes " " day "/" month "/" year)
              'face 'marco-date)))

     (setq-default mode-line-format
                   (list
                    "["
                    '(:eval
                      (let ((workspace-number (format "%d" (eyebrowse--get 'current-slot))))
                        (if (= (length workspace-number) 0)
                            ""
                          (propertize workspace-number 'face 'amirreza/workspace-face))))

                    "]"
                    "  "
                    "[" '(:eval (propertize "%b" 'face 'amirreza/buffer-face)) "]"
                    " "
                    "[" '(:eval (propertize "%m" 'face 'amirreza/mode-face)) "]"
                    " "
                    "[" '(:eval (propertize "%l,%c" 'face 'amirreza/pos-face)) "]"
                    " "

                    "[" '(:eval (when-let (vc vc-mode)
                                  (list " "
                                        (propertize (substring vc 5)
                                                    'face 'amirreza/vcs-face)
                                        " "))) "]"
                    " "
                    "[" '(:eval (propertize display-time-string 'face 'amirreza/date-face)) "] ")))

  (if-enabled? doom/modeline 
    (pkg! doom-modeline :straight t :config (setq doom-modeline-height 35) (doom-modeline-mode 1)))
    
#+end_src
** Font
#+BEGIN_SRC emacs-lisp
  (defun amirreza/change-font (font)
    (setq default-frame-alist `((font . ,font))))

  (defvar amirreza/font "Hermit-10")
  (amirreza/change-font amirreza/font)
#+END_SRC
** Tabline
#+begin_src emacs-lisp
(pkg! emacs
  :config
  (when (> emacs-major-version 26) (global-tab-line-mode -1)))
#+end_src
** Dashboard
#+begin_src emacs-lisp
  (if-enabled? dashboard 
               (pkg! dashboard
                 :straight t
                 :config
                 (setq dashboard-startup-banner 'logo)
                 (setq dashboard-center-content t)
                 (setq dashboard-items '())
                 (dashboard-setup-startup-hook)))
#+end_src
* Completion Framework
** Ivy
#+begin_src emacs-lisp
  (if-enabled? ivy
            (pkg! flx :straight t)
            (pkg! ivy
              :straight t
              :demand
              :bind
              (:map ivy-switch-buffer-map
                    ("C-k" . 'ivy-previous-line)
                    :map ivy-minibuffer-map
                    ("C-j" . 'ivy-next-line)
                    ("C-k" . 'ivy-previous-line)
                    ("RET" . 'ivy-alt-done))
              :config
              (setq ivy-height 15)
              ;; loopish cycling through list
              (setq ivy-wrap t)
              ;; don't show recents in minibuffer
              (setq ivy-use-virtual-buffers nil)
              ;; ...but if that ever changes, show their full path
              (setq ivy-virtual-abbreviate 'full)
              ;; ;; don't quit minibuffer on delete-error
              (setq ivy-on-del-error-function #'ignore)
              (setf (alist-get 't ivy-format-functions-alist)
                    #'ivy-format-function-line)
              (setq ivy-initial-inputs-alist nil)
              (setq ivy-re-builders-alist
                    '((t . ivy--regex-ignore-order)))
              (ivy-mode +1))

            (pkg! counsel
              :straight t
              :bind
              (("M-x" . 'counsel-M-x)
               ("C-x C-f" . 'counsel-find-file)
               ("C-h b" . 'counsel-descbinds)
               ("C-h f" . 'counsel-describe-function)
               ("C-h v" . 'counsel-describe-variable)
               ("C-h a" . 'counsel-apropos)
               ("M-i" . 'counsel-imenu) ;; code semantics
               ("M-y" . 'counsel-yank-pop)))
            (pkg! ivy-rich :straight t :after ivy :config (ivy-rich-mode 1))
            (pkg! ivy-posframe :straight t
              :disabled t
              :config
              (setq ivy-posframe-parameters '((parent-frame nil)))
              (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
              (ivy-posframe-mode 1))
            )
#+end_src
** Selectrum
#+begin_src emacs-lisp
  (if-enabled? selectrum 
               (pkg! selectrum-prescient :straight t)
               (pkg! selectrum
                 :straight t
                 :config
                 (selectrum-mode 1)
                 (selectrum-prescient-mode +1)
                 (prescient-persist-mode +1))

               (pkg! consult :straight t))

#+end_src
* Project Integration
#+begin_src emacs-lisp
  (pkg! project
    :straight t
    :init
    (if-enabled? evil
              (evil-global-set-key 'normal (kbd "SPC p f") 'amirreza/find-project)
              )
    :bind 
    (
     :map global-map ("C-c p" . amirreza/find-project)
     )

    :config
    (defun amirreza/find-root ()
      "Find project root."
      (let* ((project (vc-root-dir))
             (dir (if project project default-directory)))
        dir))

    (defun amirreza/is-repo (path)
      "Wether a directory is a repo or not"
      (file-exists-p (expand-file-name ".git" path)))

    (defun amirreza/find-project ()
      "List of projects in pre defined project locations."
      (interactive)
      (dired (completing-read "Project: "
                              (directory-files-recursively "~/src"
                                                           ".*"
                                                           t
                                                           (lambda (path) (not (amirreza/is-repo path)))
                                                           t)))))

#+end_src
* Searching
** Smarter file search and greping
#+begin_src emacs-lisp
  (defun amirreza/find-file ()
    (interactive)
    (find-file (amirreza/recursive-search-path "" (amirreza/find-root))))

  (defun amirreza/grep (&optional initial-input)
    "Grep."
    (interactive)
    (if-enabled? selectrum

                 (cond
                  ((not (null (executable-find "rg"))) (consult-ripgrep))
                  ((amirreza/is-repo default-directory) (consult-git-grep))
                  ((not (null (executable-find "grep"))) (consult-grep))))
    (if-enabled? ivy
                 (cond
                  ((not (null (executable-find "rg"))) (counsel-rg))
                  ((amirreza/is-repo default-directory) (counsel-git-grep))
                  ((not (null (executable-find "grep"))) (counsel-grep)))
                 )
    )

  (defun amirreza/file-finder ()
    "Find files smartly."
    (interactive)
    (if-enabled? ivy
                 (cond
                  ((not (null (executable-find "fzf"))) (counsel-fzf))
                  (t (amirreza/find-file))
                  ))
    (if-enabled?
     (cond
      ((amirreza/is-repo (amirreza/find-root)) (consult-find (amirreza/find-root)))
      (t (consult-find)))))
#+end_src
** In buffer searching
#+begin_src emacs-lisp
  (pkg! isearch :defer t)
  (if-enabled? ivy (pkg! swiper :straight t :bind ("C-s" . swiper)))
  (if-enabled? selectrum (pkg! ctrlf :straight t :bind (("C-s" . ctrlf-forward-literal) ("C-r" . ctrlf-backward-literal))))
#+end_src
** Ripgrep with persitent result
#+begin_src emacs-lisp
  (pkg! rg
    :straight t
    :commands (rg))
#+end_src
** Smart symbol and file finding
#+begin_src emacs-lisp
  (defun amirreza/recursive-search-path (initial path)
    (completing-read "Find File: " (directory-files-recursively path directory-files-no-dot-files-regexp nil (lambda (name)
                                                                                                               (not (string-match "\\.git" name)))
                                                                t) nil nil initial))
  (pkg! project
    :init
    (if-enabled? evil
              (evil-global-set-key 'normal (kbd "SPC a s") 'amirreza/find-symbol-at-point)
              (evil-global-set-key 'normal (kbd "SPC a f") 'amirreza/find-file-at-point)
              (evil-global-set-key 'normal (kbd "SPC g") 'amirreza/grep))


    :bind
    (("C-c f" . 'amirreza/file-finder)
     ("C-c g" . 'amirreza/grep)
     ("C-M-s" . 'amirreza/find-symbol-at-point)
     ("<f1>" . 'amirreza/find-file-at-point)
     ("<f2>" . 'amirreza/find-symbol-at-point)
     ("C-M-f" . 'amirreza/find-file-at-point)
     ("C-M-g" . 'amirreza/find-symbol-at-point))


    :config
    (defun amirreza/find-symbol-at-point ()
      (interactive)
      (let* ((symbol (thing-at-point 'word)))
        (amirreza/grep symbol)))

    (defun amirreza/find-file-at-point ()
      (interactive)
      (let* ((symbol (thing-at-point 'word)))
        (find-file (amirreza/recursive-search-path symbol (amirreza/find-root))))))


#+end_src
** File Type Search
#+begin_src emacs-lisp
  (setq amirreza/file-types '(music video document))
  (setq amirreza/file-type-loc '(music ("~/Music" "~/Downloads") video ("~/Videos" "~/Downloads")))
  (setq amirreza/file-type-assoc-program '(music "vlc" video "vlc" doc "xdg-open"))

  (defun amirreza/searcher ()
    (interactive)
    (let* ((filetype (completing-read "FileType: " amirreza/file-types))
           (paths (plist-get amirreza/file-type-loc (intern filetype)))
           (program (plist-get amirreza/file-type-assoc-program (intern filetype)))
           (files '())
           (_ (mapc (lambda (path)
                      (setq files (append files (directory-files-recursively path ""))))
                    paths))
           (file (completing-read "Open: " files))
           (process-name (format "%s: %s" filetype file)))
      (start-process process-name process-name program (expand-file-name file))))

#+end_src
* Emacs Buffers and Windows
** Window rules
Emacs windows can be configured in the matter of where their gonna open.
#+BEGIN_SRC emacs-lisp
    (setq display-buffer-alist
          '(("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Messages\\)\\*"
               (display-buffer-in-side-window)
               (window-width . 0.40)
               (side . right)
               (slot . 0))
            ("^vterm"
              (display-buffer-in-side-window)
              (window-width . 0.40)
              (side . right)
              (slot . 0))
            ("\*eshell.*"
              (display-buffer-in-side-window)
              (window-width . 0.40)
              (side . right)
              (slot . 0))
            ("\\*rg"
              (display-buffer-in-side-window)
              (window-width . 0.50)
              (side . right)
              (slot . 0))))
#+END_SRC
** Eyebrowse
=Eyebrowse= gives you =i3= like experience in Emacs, let's you have multiple workspaces and switch between them.
#+BEGIN_SRC emacs-lisp
  (pkg! eyebrowse 
    :straight t
    :demand
    :commands (eyebrowse-close-window-config
               eyebrowse-create-window-config
               eyebrowse-switch-to-window-config-0
               eyebrowse-switch-to-window-config-1
               eyebrowse-switch-to-window-config-2
               eyebrowse-switch-to-window-config-3
               eyebrowse-switch-to-window-config-4
               eyebrowse-switch-to-window-config-5
               eyebrowse-switch-to-window-config-6
               eyebrowse-switch-to-window-config-7
               eyebrowse-switch-to-window-config-8
               eyebrowse-switch-to-window-config-9)
    :config (eyebrowse-mode +1) 
    :bind (("C-c w 0" . eyebrowse-switch-to-window-config-0)
           ("C-c w 1" . eyebrowse-switch-to-window-config-1)
           ("C-c w 2" . eyebrowse-switch-to-window-config-2)
           ("C-c w 3" . eyebrowse-switch-to-window-config-3)
           ("C-c w 4" . eyebrowse-switch-to-window-config-4)
           ("C-c w 5" . eyebrowse-switch-to-window-config-5)
           ("C-c w 6" . eyebrowse-switch-to-window-config-6)
           ("C-c w 7" . eyebrowse-switch-to-window-config-7)
           ("C-c w 8" . eyebrowse-switch-to-window-config-8)
           ("C-c w 9" . eyebrowse-switch-to-window-config-9)
           ("C-c w n" . eyebrowse-create-window-config)
           ("C-c w c" . eyebrowse-close-window-config)))

#+END_SRC
** Winner (Restore Window layout)
When we are working with multiple windows open but we might maximize one window to focus
on it, but when we are done with focus mode ;) we need that layout back that's were winner mode
comes handy you can restore last window layout with just a function called =winner-undo= that
by default is bound to =C-c <left>=.
#+BEGIN_SRC emacs-lisp
  (pkg! winner
    :config
    (winner-mode 1)
    :commands (winner-redo winner-undo)
    :bind (("C->" . winner-redo)
           ("C-<" . winner-undo)))
#+END_SRC
** Ace Window (Better Window Management)
#+BEGIN_SRC emacs-lisp
  (pkg! ace-window
    :straight t
    :commands (ace-window)
    :bind (("C-x o" . 'ace-window)
           ("C-x C-o" . 'ace-window)))
#+END_SRC
** Ibuffer
#+begin_src emacs-lisp
  (pkg! ibuffer
    :bind (("C-x C-b" . 'ibuffer)))

  (pkg! ibuffer-vc :straight t
    :hook (ibuffer-mode . (lambda () (interactive) (ibuffer-vc-set-filter-groups-by-vc-root))))

#+end_src
* VTerm
VTerm is the best terminal emulator package for Emacs.
#+begin_src emacs-lisp
(pkg! vterm :straight t :bind ("C-c t" . vterm-other-window))
#+end_src
* Editing & Writing
** Editor zoom in/out
#+begin_src emacs-lisp
(define-key global-map (kbd "C--") (lambda () (interactive) (text-scale-adjust -1)))
(define-key global-map (kbd "C-=") (lambda () (interactive) (text-scale-adjust +1)))
#+end_src
** 10 Line Jump
#+begin_src emacs-lisp
  (global-set-key (kbd "M-n") (lambda ()
                                (interactive)
                                (forward-line 10)))
  (global-set-key (kbd "M-p") (lambda ()
                                (interactive)
                                (forward-line -10)))
#+end_src
** Highlight indentation
#+begin_src emacs-lisp
 (pkg! highlight-indent-guides
   :straight t
   :hook ((yaml-mode) . highlight-indent-guides-mode)
   :init
   (setq highlight-indent-guides-method 'character)
   :config
   (add-hook 'focus-in-hook #'highlight-indent-guides-auto-set-faces))
#+end_src
** Sudo edit
#+begin_src emacs-lisp
   (pkg! sudo-edit
        :straight t
        :commands (sudo-edit))
#+end_src
** Expand region
#+begin_src emacs-lisp
   (pkg! expand-region
     :straight t
     :bind (("C-=" . 'er/expand-region)
	    ("C--" . 'er/contract-region)))
#+end_src
** Highlight TODO/FIXME/...
#+begin_src emacs-lisp
 (pkg! hl-todo
   :straight t
   :hook ((prog-mode) . hl-todo-mode)
   :config
   (setq hl-todo-highlight-punctuation ":"
	 hl-todo-keyword-faces
	 `(("TODO"       warning bold)
	   ("FIXME"      error bold)
	   ("HACK"       font-lock-constant-face bold)
	   ("REVIEW"     font-lock-keyword-face bold)
	   ("NOTE"       success bold)
	   ("DEPRECATED" font-lock-doc-face bold))))
#+end_src
** Multiple cursors
#+begin_src emacs-lisp
      (pkg! multiple-cursors
        :straight t
        :commands (mc/edit-lines
          mc/mark-all-like-this
          mc/mark-next-like-this
          mc/skip-to-next-like-this
          mc/unmark-next-like-this
          mc/mark-previous-like-this
          mc/skip-to-previous-like-this
          mc/unmark-previous-like-this
          mc/mark-all-in-region-regexp
          mc/insert-numbers
          mc/insert-letters)
        :bind (("C-M-n" .  mc/mark-next-like-this)
               ("C-M-p" . mc/mark-previous-like-this)
               ("C-M-a" . mc/mark-all-like-this)))
#+end_src
** Don't choke on large data
#+begin_src emacs-lisp
  (pkg! so-long 
      :config (global-so-long-mode 1))
  (pkg! vlf :straight t :commands (vlf))
#+end_src
** Tramp: Edit remote files 
#+begin_src emacs-lisp
    (pkg! tramp
          :commands (tramp)
          :config
          (setq tramp-default-method "ssh"))
#+end_src
** Org
#+BEGIN_SRC emacs-lisp
  (pkg! org
  :init
  (if-enabled? evil
   (evil-define-key 'normal org-mode-map "SPC m n" 'amirreza/--org-insert-no-tangle)
   (evil-define-key 'normal org-mode-map "SPC m b" 'amirreza/--org-insert-elisp-code-block)
   )
  :config
  (defun amirreza/--org-insert-elisp-code-block ()
    (interactive)
    (insert (format "#+begin_src emacs-lisp\n\n#+end_src"))
    (previous-line)
    (beginning-of-line))

  (defun amirreza/--org-insert-no-tangle ()
    ""
    (interactive)
    (insert (format ":PROPERTIES:\n:header-args: :tangle no\n:END:\n"))
    (previous-line)
    (beginning-of-line))

  (setq org-ellipsis "â¤µ")
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-support-shift-select t)
  (setq org-src-window-setup 'current-window)
  (setq org-startup-folded t)
  :bind (:map org-mode-map
              ("C-c m n" . amirreza/--org-insert-no-tangle)
              ("C-c m b" . amirreza/--org-insert-elisp-code-block)))

  (pkg! org-bullets
    :disabled t
    :straight t
    :hook (org-mode . (lambda () (org-bullets-mode 1))))
#+END_SRC
*** Org TOC
 #+begin_src emacs-lisp
 (pkg! toc-org :straight t :hook (org-mode . toc-org-mode))
 #+end_src

*** htmlize
 #+begin_src emacs-lisp
 (pkg! htmlize :straight t :defer t)
 #+end_src
** Outline Mode
#+begin_src emacs-lisp
  (pkg! bicycle :straight t)
  (pkg! outline
    :bind (:map outline-minor-mode-map
                ("C-c C-c" . amirreza/outline-collapse-all)
                ("C-c C-a" . outline-show-all)
                ("C-M-n" . outline-forward-same-level)
                ("C-M-p" . outline-backward-same-level)
                ("M-n" . outline-next-visible-heading)
                ("<tab>" . amirreza/outline-expand-or-collapse-header)
                ("M-p" . outline-previous-visible-heading))
    :config
    (defun amirreza/outline-expand-or-collapse-header ()
      "Expand if we are on a outline heading."
      (interactive)
      (when (outline-on-heading-p)
        (bicycle-cycle)))
  
    (defun amirreza/outline-collapse-all ()
      "Hide all `outline-mode' subtrees."
      (interactive)
      (outline-map-region 'outline-hide-subtree (point-min) (point-max))))
#+end_src
** Markdown mode
#+begin_src emacs-lisp
(pkg! markdown-mode
  :straight t
  :mode ("\\.md$" . markdown-mode))
#+end_src
** Pdf tools
#+begin_src emacs-lisp
  (pkg! pdf-tools
    :straight t
    :hook (pdf-tools-enabled-hook . menu-bar-mode))
#+end_src
** Misc file modes
 #+begin_src emacs-lisp
   (pkg! crontab-mode :defer t :straight t)
   (pkg! apache-mode :straight t
     :mode ("\\.htaccess\\'" "httpd\\.conf\\'" "srm\\.conf\\'" "access\\.conf\\'"))
   (pkg! systemd :straight t
     :mode ("\\.service\\'" "\\.timer\\'"))
   (pkg! nginx-mode :straight 
     :mode ("/etc/nginx/conf.d/.*" "/etc/nginx/.*\\.conf\\'"))
 #+end_src
* Sync ENV from default shell
Emacs has a bultin shell called =eshell= which uses elisp
as it's scripting engine, I use that as my main shell over the day
but for some rare situations I have VTerm that emulates a normal terminal
and use fish in that. but before anything let's update emacs exec-path to be able to find 
all executables.
#+begin_src emacs-lisp
  (pkg! exec-path-from-shell 
    :straight t 
    :defer 1
    :config
    (setq exec-path-from-shell-shell-name "zsh")
    (exec-path-from-shell-initialize))
#+end_src
* Development
** Auto Header
#+begin_src emacs-lisp
  (pkg! autoinsert
    :hook (prog-mode . auto-insert-mode))
#+end_src
** Code Completion
Code completion consists of two parts, A source/server that provides the completions and 
an engine that knows when to open prompt and show the completions. We will configure servers later
but now we need to install the engine that shows us the completion.
=Company-mode= in my opinion is the best one out there, it consists of =backends= and =frontends=
backends connect to multiple tools that provide the completions and frontends are about the GUI.
Since we are going to use LSP as the main source for the completions we just need the default 
configuration of company.
For company backends we are going to use =company-capf= which is abbrv for =company complete at point function= which is a function in Emacs that major modes
can call an get completions based on that.
#+BEGIN_SRC emacs-lisp
  (pkg! company
    :straight t
    :hook (prog-mode . company-mode)
    :bind (:map company-active-map
                ("C-n" . company-select-next)
                ("C-p" . company-select-previous)
                ("C-o" . company-other-backend)
                ("<tab>" . company-complete-common-or-cycle)
                ("RET" . company-complete-selection))
    :config
    (setq company-minimum-prefix-lenght 1)
    (setq company-tooltip-limit 30)
    (setq company-idle-delay 0.0)
    (setq company-echo-delay 0.1)
    (setq company-show-numbers t)
    (setq company-backends '(company-capf company-dabbrev company-files company-dabbrev-code)))
#+end_src
** Movement based on language semantics 
Emacs has a builtin tool called Imenu which major modes hook to and feed it data about semantic blocks in the current buffer,
we can use it to jump around our code based on semantics of that language (forexample structs or functions).
#+begin_src emacs-lisp
    (pkg! imenu
      :bind ("M-i" . imenu))
#+end_src
** Snippets
Every human being has limited number of keystrokes left, so let's make every one of them count.
Abbrev mode is Emacs internal that expands on defined abbrevations,
Abbrev mode is really helpful but in more complicated scenarios we need more smart tool,
so we use skeleton mode and we combine that with abbrev mode to get maximum power, we are 
going to define our skeletons in their respective languages. Snippet macro defines a new snippet,
Snippets are basically combination of abbrevs and skeletons, abbrevs are used for triggering
skeleton and skeleton does it's job of inserting text.
#+begin_src emacs-lisp
  (pkg! abbrev :init (setq save-abbrevs 'silently) :commands (expand-abbrev))
  (pkg! skeleton
    :commands (amirreza/defsnippet)
    :config
    (defmacro amirreza/defsnippet (mode abbrv &rest skeleton-expansions)
      "Snippets are wrapper around skeleton and abbrevs."
      (let ((command-name (intern (format "amirreza/snippet-%s-%s" mode abbrv))))
        `(progn
           (define-skeleton ,command-name ""
             ,@skeleton-expansions)
           (define-abbrev local-abbrev-table ,abbrv "" (quote ,command-name))))))
#+end_src
** Dumb Jump
Dumb jump is actually a smart way of jumping to defenitions using grep tools like
=ag= or =rg=.
#+begin_src emacs-lisp
  (pkg! ggtags :straight t)
  (pkg! counsel-gtags :straight t
    :bind (("s-." . 'counsel-gtags-dwim)))

  (pkg! dumb-jump
        :disabled t
        :straight t
        :hook
        (xref-backend-functions . #'dumb-jump-xref-activate))
#+end_src
** LSP
*** LSP mode
   #+begin_src emacs-lisp
     (pkg! lsp-mode :straight t
       :init
       (setq lsp-file-watch-threshold 10000)
       (setq lsp-auto-guess-root t)
       (setq lsp-keymap-prefix "C-c l")
       (setq lsp-before-save-edit t)
       (defun amirreza/lsp ()
          (lsp))
  
       :hook (
              (lsp-mode . lsp-enable-which-key-integration)
              (before-save . lsp-format-buffer)))
#+end_src
*** Eglot
    :PROPERTIES:
:header-args: :tangle no
:END:
    #+begin_src emacs-lisp

  (pkg! eglot :straight t :init (defun amirreza/lsp () (eglot-ensure)))
#+end_src
** Languages
*** Go
**** Go-mode
 Golang by default is not supported in Emacs, but don't fear, we can fix that by simply installing
 =go-mode= which is a major mode and it provides the basic syntax highlighting that we need, we also
 need to configure this package to enable some LSP features that are necessary like formatting. For
 go to work perfectly you need to add the =GOPATH= to your =exec-path= to let emacs find go binaries
 that it needs.
 #+BEGIN_SRC emacs-lisp
   (pkg! go-mode
     :straight t
     :mode ("\\.go\\'" . go-mode)
     :hook
     (go-mode . amirreza/go-hook)
     (go-mode . amirreza/lsp)
     :bind
     (:map go-mode-map
           ("C-c m g t" . amirreza/snippet-go-tf)
           ("C-c m g h" . amirreza/snippet-go-hh)
           ("C-c m g f" . amirreza/snippet-go-for)
           ("C-c m g i" . amirreza/snippet-go-if)
           ("C-c m g p l" . amirreza/snippet-go-pl)
           ("C-c m g p f" . amirreza/snippet-go-pf))
     :config
     (defun amirreza/go-ggtags ()
       (interactive)
       (shell-command-to-string (format"gogtags -p %s" (amirreza/find-root)))
       )
     (defun amirreza/go-hook ()
       (interactive)
       (amirreza/defsnippet "go" "fmain" "" "func main() {" _ \n "}")
       (amirreza/defsnippet "go" "pkgm" "Package: " "package " str \n)
       (amirreza/defsnippet "go" "pl" "" "fmt.Println(\"" _ "\")")
       (amirreza/defsnippet "go" "pf" "" "fmt.Printf(\"" _ "\")")
       (amirreza/defsnippet "go" "ifer" "" "if err != nil {" \n _ \n "}")
       (amirreza/defsnippet "go" "if" "" "if " _ "{" \n "}")
       (amirreza/defsnippet "go" "for" "" "for " _ " := range {" \n \n "}")
       (amirreza/defsnippet "go" "fn" "" "func " _ "() {" \n \n "}")
       (amirreza/defsnippet "go" "tf" "" "func " _ "(t *testing.T) {" \n \n "}")
       (amirreza/defsnippet "go" "hh" "" "func " _ "(w http.ResponseWriter, r *http.Request) {" \n \n "}")

       (define-key go-mode-map (kbd "<f5> r")
         (lambda () (interactive)
           (start-process "GoRun" "*GoRun*" "go" "run" (format "%s" buffer-file-name))))

       ;; add go binaries to exec-path
       (add-to-list 'exec-path (concat (getenv "HOME") "/go/bin"))

       ;; show lambdas instead of funcs
       (setq-local prettify-symbols-alist '(("func" . 955)))
       (add-hook 'before-save-hook (lambda ()
                                     (when (amirreza/lsp?)
                                       (lsp-format-buffer)
                                       (lsp-organize-imports))) t t)))

 #+END_SRC
**** Go-add-tags
 it's always a pain to manually add struct tags for a struct specially when
 the struct has so many fields, again thanks to the emacs community we have package for that 
 to ease that task for us.
 #+BEGIN_SRC emacs-lisp
   (pkg! go-add-tags :straight t :bind (:map go-mode-map ("C-c m s" . go-add-tags)))
 #+END_SRC
**** Go-test
 =VSCode= has a great support when it comes to running go tests, it gives you the ability to 
 run a test when you are editing or viewing it but it does'nt mean that Emacs can't do that.
 #+BEGIN_SRC emacs-lisp
   (pkg! gotest :straight t 
     :after go-mode
     :config
     (define-key go-mode-map (kbd "C-c m t f") 'go-test-current-file) 
     (define-key go-mode-map (kbd "C-c m t t") 'go-test-current-test))
  #+END_SRC
*** C/C++
#+begin_src emacs-lisp
  (pkg! ccls :straight t)
  ;;(pkg! cmake-mode :defer t :straight t)
  ;;(pkg! disaster :defer t :straight t)
#+end_src
*** Java
#+begin_src emacs-lisp
  (pkg! gradle-mode :straight t :mode "\\Gradle")
  (pkg! flycheck-gradle :straight t :mode "Gradle")
  (pkg! groovy-mode :straight t :mode "\\.groovy")
  ;; (pkg! meghanada :straight t :hook (java-mode . (lambda ()
  ;;                                                         (meghanada-mode t)
  ;;                                                         (flycheck-mode +1)
  ;;                                                         (setq c-basic-offset 2))))
  (pkg! lsp-java :straight t)
#+end_src
*** Python
**** Python Mode
 Emacs itself comes with =python-mode= which is python major mode that provides emacs with 
 syntax highlighting and some other features on python, so we just need to configure it the way 
 we want. I added some custom python functions to suit my python needs like the docstring function
 that inserts a docstring in python syntax.
 #+BEGIN_SRC emacs-lisp
   (pkg! python-mode
     :mode "\\.py\\'"
     :hook
     (python-mode . amirreza/lsp)
     :config
     (defun amirreza/python-insert-docstring ()
       (interactive)
       (insert "'''\n'''")
       (previous-line))
     :bind
     (:map python-mode-map 
       ("C-c m d" . amirreza/python-insert-docstring)))
 #+END_SRC
**** Microsoft Language Server
 #+begin_src emacs-lisp
 (pkg! lsp-python-ms :straight t :after python-mode)
 #+end_src
**** Pipenv
 =Pipenv= is now the de facto tool for python programmers to manage their project deps, so it's nice
 to have a wrapper for it in Emacs.
 #+BEGIN_SRC emacs-lisp
   (pkg! pipenv
	        :straight t
	        :after python-mode)
 #+END_SRC
**** Py-autopep8
 We are using LSP for all our IDE like features but right now python lanugage server does not
 provide formmatting feature for python so we need to use another package called =py-autopep8= which
 actually is just a wrapper around python package that you need to install from =pypi= called 
 no suprises =py-autopep8=. We install this package and we need this package to hook it's format 
 function to =before-save-hook= of emacs, luckily this package provides a helper function to do that.
 #+BEGIN_SRC emacs-lisp
 (pkg! py-autopep8
   :straight t
   :hook python-mode
   :config
   (py-autopep8-enable-on-save))

 #+END_SRC
*** Scheme
 I use guile as my scheme compiler.
 #+begin_src emacs-lisp
   (pkg! scheme
   :mode "\\.scm"
   :config
   (setq scheme-program-name "guile"))
 #+end_src
*** Lua
#+begin_src emacs-lisp
(pkg! lua-mode :straight t :mode "\\.lua" :hook (lua-mode . amirreza/lsp))
#+end_src
*** Zig
 #+begin_src emacs-lisp
   (pkg! zig-mode 
     :straight t
     :mode "\\.zig\\'")
 #+end_src
*** Lisp configuration
#+begin_src emacs-lisp
  (pkg! paredit :straight t
    :hook ((clojure-mode emacs-lisp-mode) . paredit-mode))
  (pkg! parinfer :straight t  :hook ((clojure-mode emacs-lisp-mode) . parinfer-mode))
#+end_src
*** Emacs lisp
 Emacs lisp should be supported by default ha ? actually it has almost all support you need but 
 we can even go further.x
 #+BEGIN_SRC emacs-lisp
   (pkg! elisp-mode
     :hook
     (emacs-lisp-mode-hook . amirreza/elisp-hook)
     :config
     (defun amirreza/elisp-hook ()
       (setq-local prettify-symbols-alist '(("fn" . 955)))
       (defun --amirreza/emacs-lisp-repeat (str count)
         "Create dashes with given COUNT."
         (let ((dashes ""))
           (dotimes (iterator count dashes)
             (setq dashes (concat dashes str)))))

       (defun --amirreza/emacs-lisp-wrap-text-in-spaces (text)
         (let* ((len (length text))
                (spaces-length-side (/ (- 80 len) 2))
                (spaces-side (--amirreza/emacs-lisp-repeat " " spaces-length-side)))
           (format "%s%s%s" spaces-side text spaces-side)))

       (defun amirreza/emacs-lisp-insert-comment-line (text)
         "Insert a comment line with given TEXT."
         (interactive "sComment: ")
         (let* ((text-wrapped (--amirreza/emacs-lisp-wrap-text-in-spaces text))
                (dashes (--amirreza/emacs-lisp-repeat "=" 80))))
         (insert (format "\n;;%s\n;;%s\n;;%s" dashes text-wrapped dashes))))
     :bind
     (:map emacs-lisp-mode-map
           ("C-c m c" . 'amirreza/emacs-lisp-insert-comment-line)))
 #+END_SRC
*** Clojure
**** Clojure Mode
     #+BEGIN_SRC emacs-lisp
       (pkg! clojure-mode :straight t
         :mode "\\.cljs?\\'"
         :hook
         (clojure-mode . amirreza/lsp)
         :config
         (setq-local prettify-symbols-alist '(("fn" . 955) ; Î»
                                               ("->" . 8594))))
     #+END_SRC
**** Cider
 #+BEGIN_SRC emacs-lisp
   (pkg! cider 
     :straight t
     :commands (cider cider-jack-in))
 #+END_SRC
*** Common Lisp
**** Common-lisp mode
 #+BEGIN_SRC emacs-lisp
 (pkg! lisp-mode :mode "\\.cl\\'")
 #+END_SRC
**** Common Lisp Integrated Environment
 #+BEGIN_SRC emacs-lisp
 (pkg! sly :straight t :mode "\\.cl\\'")
 #+END_SRC
*** Haskell
**** Haskell mode
 #+BEGIN_SRC emacs-lisp
 (pkg! haskell-mode :straight t :mode "\\.hs\\'")
 #+END_SRC
**** Haskell IDE engine
 #+BEGIN_SRC emacs-lisp
 (pkg! lsp-haskell :straight t :hook haskell-mode)
 #+END_SRC
*** HTML/CSS
 #+BEGIN_SRC emacs-lisp
   (pkg! web-mode :straight t :mode ("\\.html\\'" "\\.css\\'") :config (web-mode-toggle-current-element-highlight))
 #+END_SRC
*** PHP
**** PHP mode
 #+BEGIN_SRC emacs-lisp
   (pkg! php-mode :straight t 
     :mode "\\.php\\'")
 #+END_SRC
**** PHP Runtime Integration
 #+BEGIN_SRC emacs-lisp
 (pkg! php-runtime :straight t :after php-mode)
 #+END_SRC
**** Composer Integration
 #+BEGIN_SRC emacs-lisp
   (pkg! composer :straight t :after php-mode)
 #+END_SRC
**** PHPUnit
 #+BEGIN_SRC emacs-lisp
   (pkg! phpunit :straight t
     :after php-mode
     :config 
     (define-key php-mode-map (kbd "C-c m t t") 'phpunit-current-test)
     (define-key php-mode-map (kbd "C-c m t c")  'phpunit-current-class)
     (define-key php-mode-map (kbd "C-c m t p")  'phpunit-current-project))
 #+END_SRC
*** Rust
 #+BEGIN_SRC emacs-lisp
   (pkg! rustic
     :straight t
     :mode ("\\.rs\\'" . rustic-mode)
     :hook
     (rust-mode . amirreza/lsp)
     :config
     (setq rustic-format-on-save t))
 #+END_SRC
*** Protobuf
#+begin_src emacs-lisp
(pkg! protobuf-mode :straight t :mode "\\.proto\\'")
#+end_src
*** Nix
#+begin_src emacs-lisp
(pkg! nix-mode :straight t :mode "\\.nix'")
#+end_src
*** Terraform
#+begin_src emacs-lisp
(pkg! terraform-mode :straight t :mode "\\.tf")
#+end_src
** Debugger
#+begin_src emacs-lisp
  (pkg! dap-mode :straight t
    :defer t
    :disabled t
    :config
    (dap-ui-mode 1)
    ;; enables mouse hover support
    (dap-tooltip-mode 1)
    ;; use tooltips for mouse hover
    ;; if it is not enabled `dap-mode' will use the minibuffer.
    (tooltip-mode 1)
    ;; displays floating panel with debug buttons
    ;; requies emacs 26+
    (dap-ui-controls-mode 1)
    (require 'dap-go))
#+end_src
** Rainbow delimiters
#+begin_src emacs-lisp
(pkg! rainbow-delimiters :straight t :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Docs
#+begin_src emacs-lisp
  (pkg! eldoc
    :config (global-eldoc-mode 1))
#+end_src
** VCS
#+BEGIN_SRC emacs-lisp
  (pkg! magit
    :straight t
    :commands (magit-status magit-get-current-branch)
    :init
    (if-enabled? evil (evil-global-set-key 'normal (kbd "SPC v g") 'magit-status))
    :bind
    (("C-x g" . 'magit-status)
     ("C-c v s" . 'magit-status)
     )
    )

  (pkg! diff-hl
    :straight t
    :config (global-diff-hl-mode 1))

  (pkg! gitconfig-mode
    :straight t
    :mode "/\\.gitconfig\\'")

  (pkg! gitignore-mode
    :straight t
    :mode "/\\.gitignore\\'")

  (pkg! gitattributes-mode
    :straight t
    :mode "/\\.gitattributes\\'")

  (pkg! git-messenger
    :straight t
    :commands
    (git-messenger:popup-message)
    :bind
    (("C-c v b" . git-messenger:popup-message))

    :config
    (setq git-messenger:show-detail t)
    (setq git-messenger:use-magit-popup t))
#+END_SRC
* File Manager (Dired)
#+begin_src emacs-lisp
  (pkg! dired
    :commands (dired dired-jump)
    :hook (dired-hook . (lambda () (interactive) (dired-hide-details-mode 1)))
    :bind (("C-x C-j" . dired-jump)
           :map dired-mode-map
           ("q" . kill-this-buffer)))
  (pkg! dired-x
      :config
      (setq cmd "xdg-open")
      (setq dired-guess-shell-alist-user
            `(("\\.\\(?:docx\\|pdf\\|djvu\\|eps\\)\\'" ,cmd)
              ("\\.\\(?:jpe?g\\|png\\|gif\\|xpm\\)\\'" ,cmd)
              ("\\.\\(?:xcf\\)\\'" ,cmd)
              ("\\.csv\\'" ,cmd)
              ("\\.tex\\'" ,cmd)
              ("\\.\\(?:mp4\\|mkv\\|avi\\|flv\\|rm\\|rmvb\\|ogv\\)\\(?:\\.part\\)?\\'" "vlc")
              ("\\.\\(?:mp3\\|flac\\)\\'" ,cmd)
              ("\\.html?\\'" ,cmd)
              ("\\.md\\'" ,cmd))))
  
  (pkg! dired-sidebar :straight t
    :bind
    (("<f8>" . dired-sidebar-toggle-sidebar)))

  (pkg! dired-subtree
    :straight t
    :bind (:map dired-mode-map
                ("<tab>" . dired-subtree-toggle)))
#+end_src
* Integrated Tools
** Process management
#+begin_src emacs-lisp
  (pkg! proced
    :bind (("<f10>" . amirreza/kill-process))
    :commands (proced amirreza/kill-process)
    :config

    (defun amirreza/kill-process (name)
      (interactive "sProcess: ")
      (shell-command-to-string (format "pkill %s" name))))
#+end_src
** Rhythmbox
#+begin_src emacs-lisp
  (if-enabled? rhythmbox
               (pkg! rhythmbox
                 :bind (("C-c i m l" . Rhythmbox)
                        ("C-c i m p" . Rhythmbox/playpause-current-song)
                        ("C-c i m n" . Rhythmbox/current-song-name))
                 :load-path "~/.emacs.d/site-lisp/"))
#+end_src
** Video
#+begin_src emacs-lisp
  (defun amirreza/start-vlc (filename)
    (start-process (format "*VLC: %s*" filename) "*VLC*" "vlc" filename))

  (defvar amirreza/video-location "~/Videos")

  (defun amirreza/video-list ()
    (interactive)
    (amirreza/start-vlc (expand-file-name (completing-read "Video: " (directory-files-recursively amirreza/video-location ".*")))))
#+end_src
** Docker
#+BEGIN_SRC emacs-lisp
  (pkg! docker-compose-mode
    :straight t
    :mode "docker-compose\\.yml")

  (pkg! docker :straight t 
    :bind
    ("C-c i d" . docker))
  (pkg! dockerfile-mode :straight t :mode "\\Dockerfile\\'")
#+END_SRC
** Kubernetes
#+begin_src emacs-lisp
(pkg! kubel :straight t :commands (kubel) :bind (("C-c i k" . kubel)))
#+end_src
** Application Laucnher(dmenu)
Dmenu replacement in Emacs.
#+begin_src emacs-lisp
  (defun amirreza/run-command (cmd)
    (let* ((process-name (format "External: %s" cmd))
           (args ""))
      (when (string-match-p "\\.desktop" cmd)
        (setq args cmd)
        (setq cmd "gtk-launch"))

      (start-process process-name process-name cmd (car (last (split-string args "/"))))))

  (defun amirreza/launch ()
    (interactive)
    (let* ((bins '())
           (_ (mapc (lambda (path)
                      (ignore-errors (setq bins (append bins (directory-files-recursively path directory-files-no-dot-files-regexp))))
                      ) exec-path))
           (cmd (completing-read "Run: " bins)))
      (amirreza/run-command cmd)))

(global-set-key (kbd "s-d") 'amirreza/launch)
#+end_src
** Terminal
#+begin_src emacs-lisp
  (defvar amirreza/terminal "alacritty")
    (defun amirreza/terminal ()
      (interactive)
      (start-process (format "%s: %s" amirreza/terminal default-directory)
                     (format "%s: %s" amirreza/terminal default-directory) "alacritty"))
#+end_src
* Dotfiles
I use multiple programs that holds their configuration in files, this section are some helpers for editing the configs
of Emacs and other programs.
#+begin_src emacs-lisp
  (defvar amirreza/dotfiles-location (exec-path-from-shell-copy-env "DOTFILES") "Location of my dotfiles.")

    (defun amirreza/edit-dot-config ()
      (interactive)
      (find-file (completing-read "Edit: " (directory-files-recursively amirreza/dotfiles-location ".*" nil (lambda (name)
                                                                                                              (not (string-match "\\.git" name)))
                                                                                                                   t))))
  (global-set-key (kbd "<f9>") 'amirreza/edit-dot-config)

  (global-set-key (kbd "C-c e c") 'amirreza/edit-dot-config)

#+end_src
